{"/home/travis/build/npmtest/node-npmtest-prettier/test.js":"/* istanbul instrument in package npmtest_prettier */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-prettier/lib.npmtest_prettier.js":"/* istanbul instrument in package npmtest_prettier */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_prettier = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_prettier = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-prettier/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-prettier && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_prettier */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_prettier\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_prettier.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_prettier.rollup.js'] =\n            local.assetsDict['/assets.npmtest_prettier.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_prettier.__dirname + '/lib.npmtest_prettier.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-prettier/node_modules/prettier/index.js":"\"use strict\";\n\nconst codeFrame = require(\"babel-code-frame\");\nconst comments = require(\"./src/comments\");\nconst version = require(\"./package.json\").version;\nconst printAstToDoc = require(\"./src/printer\").printAstToDoc;\nconst printDocToString = require(\"./src/doc-printer\").printDocToString;\nconst normalizeOptions = require(\"./src/options\").normalize;\nconst parser = require(\"./src/parser\");\nconst printDocToDebug = require(\"./src/doc-debug\").printDocToDebug;\n\nfunction guessLineEnding(text) {\n  const index = text.indexOf(\"\\n\");\n  if (index >= 0 && text.charAt(index - 1) === \"\\r\") {\n    return \"\\r\\n\";\n  }\n  return \"\\n\";\n}\n\nfunction parse(text, opts) {\n  let parseFunction;\n\n  if (opts.parser === \"flow\") {\n    parseFunction = parser.parseWithFlow;\n  } else if (opts.parser === \"typescript\") {\n    parseFunction = parser.parseWithTypeScript;\n  } else {\n    parseFunction = parser.parseWithBabylon;\n  }\n\n  try {\n    return parseFunction(text);\n  } catch (error) {\n    const loc = error.loc;\n\n    if (loc) {\n      error.codeFrame = codeFrame(text, loc.line, loc.column + 1, {\n        highlightCode: true\n      });\n      error.message += \"\\n\" + error.codeFrame;\n    }\n\n    throw error;\n  }\n}\n\nfunction attachComments(text, ast, opts) {\n  const astComments = ast.comments;\n  if (astComments) {\n    delete ast.comments;\n    comments.attach(astComments, ast, text, opts);\n  }\n  ast.tokens = [];\n  opts.originalText = text.trimRight();\n  return astComments;\n}\n\nfunction ensureAllCommentsPrinted(astComments) {\n  for (let i = 0; i < astComments.length; ++i) {\n    if (astComments[i].value.trim() === \"prettier-ignore\") {\n      // If there's a prettier-ignore, we're not printing that sub-tree so we\n      // don't know if the comments was printed or not.\n      return;\n    }\n  }\n\n  astComments.forEach(comment => {\n    if (!comment.printed) {\n      throw new Error(\n        'Comment \"' +\n          comment.value.trim() +\n          '\" was not printed. Please report this error!'\n      );\n    }\n    delete comment.printed;\n  });\n}\n\nfunction format(text, opts) {\n  const ast = parse(text, opts);\n  const astComments = attachComments(text, ast, opts);\n  const doc = printAstToDoc(ast, opts);\n  opts.newLine = guessLineEnding(text);\n  const str = printDocToString(doc, opts);\n  ensureAllCommentsPrinted(astComments);\n  return str;\n}\n\nfunction formatWithShebang(text, opts) {\n  if (!text.startsWith(\"#!\")) {\n    return format(text, opts);\n  }\n\n  const index = text.indexOf(\"\\n\");\n  const shebang = text.slice(0, index + 1);\n  const programText = text.slice(index + 1);\n  const nextChar = text.charAt(index + 1);\n  const newLine = nextChar === \"\\n\" ? \"\\n\" : nextChar === \"\\r\" ? \"\\r\\n\" : \"\";\n\n  return shebang + newLine + format(programText, opts);\n}\n\nmodule.exports = {\n  format: function(text, opts) {\n    return formatWithShebang(text, normalizeOptions(opts));\n  },\n  check: function(text, opts) {\n    try {\n      const formatted = this.format(text, opts);\n      return formatted === text;\n    } catch (e) {\n      return false;\n    }\n  },\n  version: version,\n  __debug: {\n    formatAST: function(ast, opts) {\n      opts = normalizeOptions(opts);\n      const doc = printAstToDoc(ast, opts);\n      const str = printDocToString(doc, opts);\n      return str;\n    },\n    // Doesn't handle shebang for now\n    formatDoc: function(doc, opts) {\n      opts = normalizeOptions(opts);\n      const debug = printDocToDebug(doc);\n      const str = format(debug, opts);\n      return str;\n    },\n    printToDoc: function(text, opts) {\n      opts = normalizeOptions(opts);\n      const ast = parse(text, opts);\n      attachComments(text, ast, opts);\n      const doc = printAstToDoc(ast, opts);\n      return doc;\n    },\n    printDocToString: function(doc, opts) {\n      opts = normalizeOptions(opts);\n      const str = printDocToString(doc, opts);\n      return str;\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-prettier/node_modules/prettier/src/comments.js":"\"use strict\";\n\nvar assert = require(\"assert\");\nvar types = require(\"ast-types\");\nvar n = types.namedTypes;\nvar isArray = types.builtInTypes.array;\nvar isObject = types.builtInTypes.object;\nvar docBuilders = require(\"./doc-builders\");\nvar fromString = docBuilders.fromString;\nvar concat = docBuilders.concat;\nvar hardline = docBuilders.hardline;\nvar breakParent = docBuilders.breakParent;\nvar indent = docBuilders.indent;\nvar align = docBuilders.align;\nvar lineSuffix = docBuilders.lineSuffix;\nvar join = docBuilders.join;\nvar util = require(\"./util\");\nvar childNodesCacheKey = Symbol(\"child-nodes\");\nvar locStart = util.locStart;\nvar locEnd = util.locEnd;\nvar getNextNonSpaceNonCommentCharacter =\n  util.getNextNonSpaceNonCommentCharacter;\n\n// TODO Move a non-caching implementation of this function into ast-types,\n// and implement a caching wrapper function here.\nfunction getSortedChildNodes(node, text, resultArray) {\n  if (!node) {\n    return;\n  }\n\n  if (resultArray) {\n    if (n.Node.check(node) && node.type !== \"EmptyStatement\") {\n      // This reverse insertion sort almost always takes constant\n      // time because we almost always (maybe always?) append the\n      // nodes in order anyway.\n      for (var i = resultArray.length - 1; i >= 0; --i) {\n        if (\n          locStart(resultArray[i]) <= locStart(node) &&\n          locEnd(resultArray[i]) <= locEnd(node)\n        ) {\n          break;\n        }\n      }\n      resultArray.splice(i + 1, 0, node);\n      return;\n    }\n  } else if (node[childNodesCacheKey]) {\n    return node[childNodesCacheKey];\n  }\n\n  var names;\n  if (isArray.check(node)) {\n    names = Object.keys(node);\n  } else if (isObject.check(node)) {\n    names = types.getFieldNames(node);\n  } else {\n    return;\n  }\n\n  if (!resultArray) {\n    Object.defineProperty(node, childNodesCacheKey, {\n      value: (resultArray = []),\n      enumerable: false\n    });\n  }\n\n  for (var i = 0, nameCount = names.length; i < nameCount; ++i) {\n    getSortedChildNodes(node[names[i]], text, resultArray);\n  }\n\n  return resultArray;\n}\n\n// As efficiently as possible, decorate the comment object with\n// .precedingNode, .enclosingNode, and/or .followingNode properties, at\n// least one of which is guaranteed to be defined.\nfunction decorateComment(node, comment, text) {\n  var childNodes = getSortedChildNodes(node, text);\n  var precedingNode, followingNode;\n  // Time to dust off the old binary search robes and wizard hat.\n  var left = 0, right = childNodes.length;\n  while (left < right) {\n    var middle = (left + right) >> 1;\n    var child = childNodes[middle];\n\n    if (\n      locStart(child) - locStart(comment) <= 0 &&\n      locEnd(comment) - locEnd(child) <= 0\n    ) {\n      // The comment is completely contained by this child node.\n      comment.enclosingNode = child;\n\n      decorateComment(child, comment, text);\n      return; // Abandon the binary search at this level.\n    }\n\n    if (locEnd(child) - locStart(comment) <= 0) {\n      // This child node falls completely before the comment.\n      // Because we will never consider this node or any nodes\n      // before it again, this node must be the closest preceding\n      // node we have encountered so far.\n      precedingNode = child;\n      left = middle + 1;\n      continue;\n    }\n\n    if (locEnd(comment) - locStart(child) <= 0) {\n      // This child node falls completely after the comment.\n      // Because we will never consider this node or any nodes after\n      // it again, this node must be the closest following node we\n      // have encountered so far.\n      followingNode = child;\n      right = middle;\n      continue;\n    }\n\n    throw new Error(\"Comment location overlaps with node location\");\n  }\n\n  if (precedingNode) {\n    comment.precedingNode = precedingNode;\n  }\n\n  if (followingNode) {\n    comment.followingNode = followingNode;\n  }\n}\n\nfunction attach(comments, ast, text, options) {\n  if (!isArray.check(comments)) {\n    return;\n  }\n\n  var tiesToBreak = [];\n\n  comments.forEach((comment, i) => {\n    decorateComment(ast, comment, text);\n\n    const precedingNode = comment.precedingNode;\n    const enclosingNode = comment.enclosingNode;\n    const followingNode = comment.followingNode;\n\n    const isLastComment = comments.length - 1 === i;\n\n    if (util.hasNewline(text, locStart(comment), { backwards: true })) {\n      // If a comment exists on its own line, prefer a leading comment.\n      // We also need to check if it's the first line of the file.\n      if (\n        handleLastFunctionArgComments(\n          text,\n          precedingNode,\n          enclosingNode,\n          followingNode,\n          comment\n        ) ||\n        handleMemberExpressionComments(enclosingNode, followingNode, comment) ||\n        handleIfStatementComments(\n          text,\n          precedingNode,\n          enclosingNode,\n          followingNode,\n          comment\n        ) ||\n        handleTryStatementComments(enclosingNode, followingNode, comment) ||\n        handleClassComments(enclosingNode, comment) ||\n        handleImportSpecifierComments(enclosingNode, comment) ||\n        handleObjectPropertyComments(enclosingNode, comment) ||\n        handleForComments(enclosingNode, precedingNode, comment) ||\n        handleUnionTypeComments(\n          precedingNode,\n          enclosingNode,\n          followingNode,\n          comment\n        ) ||\n        handleOnlyComments(enclosingNode, ast, comment, isLastComment) ||\n        handleImportDeclarationComments(\n          enclosingNode,\n          precedingNode,\n          comment\n        ) ||\n        handleAssignmentPatternComments(enclosingNode, comment)\n      ) {\n        // We're good\n      } else if (followingNode) {\n        // Always a leading comment.\n        addLeadingComment(followingNode, comment);\n      } else if (precedingNode) {\n        addTrailingComment(precedingNode, comment);\n      } else if (enclosingNode) {\n        addDanglingComment(enclosingNode, comment);\n      } else {\n        // There are no nodes, let's attach it to the root of the ast\n        addDanglingComment(ast, comment);\n      }\n    } else if (util.hasNewline(text, locEnd(comment))) {\n      if (\n        handleConditionalExpressionComments(\n          enclosingNode,\n          precedingNode,\n          followingNode,\n          comment,\n          text\n        ) ||\n        handleImportSpecifierComments(enclosingNode, comment) ||\n        handleTemplateLiteralComments(enclosingNode, comment) ||\n        handleIfStatementComments(\n          text,\n          precedingNode,\n          enclosingNode,\n          followingNode,\n          comment\n        ) ||\n        handleClassComments(enclosingNode, comment) ||\n        handleLabeledStatementComments(enclosingNode, comment) ||\n        handleCallExpressionComments(precedingNode, enclosingNode, comment) ||\n        handlePropertyComments(enclosingNode, comment) ||\n        handleExportNamedDeclarationComments(enclosingNode, comment) ||\n        handleOnlyComments(enclosingNode, ast, comment, isLastComment) ||\n        handleClassMethodComments(enclosingNode, comment) ||\n        handleTypeAliasComments(enclosingNode, followingNode, comment) ||\n        handleVariableDeclaratorComments(enclosingNode, followingNode, comment)\n      ) {\n        // We're good\n      } else if (precedingNode) {\n        // There is content before this comment on the same line, but\n        // none after it, so prefer a trailing comment of the previous node.\n        addTrailingComment(precedingNode, comment);\n      } else if (followingNode) {\n        addLeadingComment(followingNode, comment);\n      } else if (enclosingNode) {\n        addDanglingComment(enclosingNode, comment);\n      } else {\n        // There are no nodes, let's attach it to the root of the ast\n        addDanglingComment(ast, comment);\n      }\n    } else {\n      if (\n        handleIfStatementComments(\n          text,\n          precedingNode,\n          enclosingNode,\n          followingNode,\n          comment\n        ) ||\n        handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) ||\n        handleTemplateLiteralComments(enclosingNode, comment) ||\n        handleCommentInEmptyParens(text, enclosingNode, comment) ||\n        handleOnlyComments(enclosingNode, ast, comment, isLastComment)\n      ) {\n        // We're good\n      } else if (precedingNode && followingNode) {\n        // Otherwise, text exists both before and after the comment on\n        // the same line. If there is both a preceding and following\n        // node, use a tie-breaking algorithm to determine if it should\n        // be attached to the next or previous node. In the last case,\n        // simply attach the right node;\n        const tieCount = tiesToBreak.length;\n        if (tieCount > 0) {\n          var lastTie = tiesToBreak[tieCount - 1];\n          if (lastTie.followingNode !== comment.followingNode) {\n            breakTies(tiesToBreak, text);\n          }\n        }\n        tiesToBreak.push(comment);\n      } else if (precedingNode) {\n        addTrailingComment(precedingNode, comment);\n      } else if (followingNode) {\n        addLeadingComment(followingNode, comment);\n      } else if (enclosingNode) {\n        addDanglingComment(enclosingNode, comment);\n      } else {\n        // There are no nodes, let's attach it to the root of the ast\n        addDanglingComment(ast, comment);\n      }\n    }\n  });\n\n  breakTies(tiesToBreak, text);\n\n  comments.forEach(function(comment) {\n    // These node references were useful for breaking ties, but we\n    // don't need them anymore, and they create cycles in the AST that\n    // may lead to infinite recursion if we don't delete them here.\n    delete comment.precedingNode;\n    delete comment.enclosingNode;\n    delete comment.followingNode;\n  });\n}\n\nfunction breakTies(tiesToBreak, text) {\n  var tieCount = tiesToBreak.length;\n  if (tieCount === 0) {\n    return;\n  }\n\n  var precedingNode = tiesToBreak[0].precedingNode;\n  var followingNode = tiesToBreak[0].followingNode;\n  var gapEndPos = locStart(followingNode);\n\n  // Iterate backwards through tiesToBreak, examining the gaps\n  // between the tied comments. In order to qualify as leading, a\n  // comment must be separated from followingNode by an unbroken series of\n  // whitespace-only gaps (or other comments).\n  for (\n    var indexOfFirstLeadingComment = tieCount;\n    indexOfFirstLeadingComment > 0;\n    --indexOfFirstLeadingComment\n  ) {\n    var comment = tiesToBreak[indexOfFirstLeadingComment - 1];\n    assert.strictEqual(comment.precedingNode, precedingNode);\n    assert.strictEqual(comment.followingNode, followingNode);\n\n    var gap = text.slice(locEnd(comment), gapEndPos);\n    if (/\\S/.test(gap)) {\n      // The gap string contained something other than whitespace.\n      break;\n    }\n\n    gapEndPos = locStart(comment);\n  }\n\n  tiesToBreak.forEach(function(comment, i) {\n    if (i < indexOfFirstLeadingComment) {\n      addTrailingComment(precedingNode, comment);\n    } else {\n      addLeadingComment(followingNode, comment);\n    }\n  });\n\n  tiesToBreak.length = 0;\n}\n\nfunction addCommentHelper(node, comment) {\n  var comments = node.comments || (node.comments = []);\n  comments.push(comment);\n  comment.printed = false;\n}\n\nfunction addLeadingComment(node, comment) {\n  comment.leading = true;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\n\nfunction addDanglingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\n\nfunction addTrailingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = true;\n  addCommentHelper(node, comment);\n}\n\nfunction addBlockStatementFirstComment(node, comment) {\n  const body = node.body.filter(n => n.type !== \"EmptyStatement\");\n  if (body.length === 0) {\n    addDanglingComment(node, comment);\n  } else {\n    addLeadingComment(body[0], comment);\n  }\n}\n\nfunction addBlockOrNotComment(node, comment) {\n  if (node.type === \"BlockStatement\") {\n    addBlockStatementFirstComment(node, comment);\n  } else {\n    addLeadingComment(node, comment);\n  }\n}\n\n// There are often comments before the else clause of if statements like\n//\n//   if (1) { ... }\n//   // comment\n//   else { ... }\n//\n// They are being attached as leading comments of the BlockExpression which\n// is not well printed. What we want is to instead move the comment inside\n// of the block and make it leadingComment of the first element of the block\n// or dangling comment of the block if there is nothing inside\n//\n//   if (1) { ... }\n//   else {\n//     // comment\n//     ...\n//   }\nfunction handleIfStatementComments(\n  text,\n  precedingNode,\n  enclosingNode,\n  followingNode,\n  comment\n) {\n  if (\n    !enclosingNode || enclosingNode.type !== \"IfStatement\" || !followingNode\n  ) {\n    return false;\n  }\n\n  // We unfortunately have no way using the AST or location of nodes to know\n  // if the comment is positioned before or after the condition parenthesis:\n  //   if (a /* comment */) {}\n  //   if (a) /* comment */ {}\n  // The only workaround I found is to look at the next character to see if\n  // it is a ).\n  if (getNextNonSpaceNonCommentCharacter(text, comment) === \")\") {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"BlockStatement\") {\n    addBlockStatementFirstComment(followingNode, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"IfStatement\") {\n    addBlockOrNotComment(followingNode.consequent, comment);\n    return true;\n  }\n\n  return false;\n}\n\n// Same as IfStatement but for TryStatement\nfunction handleTryStatementComments(enclosingNode, followingNode, comment) {\n  if (\n    !enclosingNode || enclosingNode.type !== \"TryStatement\" || !followingNode\n  ) {\n    return false;\n  }\n\n  if (followingNode.type === \"BlockStatement\") {\n    addBlockStatementFirstComment(followingNode, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"TryStatement\") {\n    addBlockOrNotComment(followingNode.finalizer, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"CatchClause\") {\n    addBlockOrNotComment(followingNode.body, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleMemberExpressionComments(enclosingNode, followingNode, comment) {\n  if (\n    enclosingNode &&\n    enclosingNode.type === \"MemberExpression\" &&\n    followingNode &&\n    followingNode.type === \"Identifier\"\n  ) {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleConditionalExpressionComments(\n  enclosingNode,\n  precedingNode,\n  followingNode,\n  comment,\n  text\n) {\n  const isSameLineAsPrecedingNode =\n    precedingNode &&\n    !util.hasNewlineInRange(text, locEnd(precedingNode), locStart(comment));\n\n  if (\n    (!precedingNode || !isSameLineAsPrecedingNode) &&\n    enclosingNode &&\n    enclosingNode.type === \"ConditionalExpression\" &&\n    followingNode\n  ) {\n    addLeadingComment(followingNode, comment);\n    return true;\n  }\n  return false;\n}\n\nfunction handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) {\n  if (\n    enclosingNode &&\n    (enclosingNode.type === \"ObjectProperty\" ||\n      enclosingNode.type === \"Property\") &&\n    enclosingNode.shorthand &&\n    enclosingNode.key === precedingNode &&\n    enclosingNode.value.type === \"AssignmentPattern\"\n  ) {\n    addTrailingComment(enclosingNode.value.left, comment);\n    return true;\n  }\n  return false;\n}\n\nfunction handleTemplateLiteralComments(enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"TemplateLiteral\") {\n    const expressionIndex = findExpressionIndexForComment(\n      enclosingNode.quasis,\n      comment\n    );\n    // Enforce all comments to be leading block comments.\n    comment.type = \"CommentBlock\";\n    addLeadingComment(enclosingNode.expressions[expressionIndex], comment);\n    return true;\n  }\n  return false;\n}\n\nfunction handleCommentInEmptyParens(text, enclosingNode, comment) {\n  if (getNextNonSpaceNonCommentCharacter(text, comment) !== \")\") {\n    return false;\n  }\n\n  // Only add dangling comments to fix the case when no params are present,\n  // i.e. a function without any argument.\n  if (\n    enclosingNode &&\n    (((enclosingNode.type === \"FunctionDeclaration\" ||\n      enclosingNode.type === \"FunctionExpression\" ||\n      enclosingNode.type === \"ArrowFunctionExpression\" ||\n      enclosingNode.type === \"ClassMethod\" ||\n      enclosingNode.type === \"ObjectMethod\") &&\n      enclosingNode.params.length === 0) ||\n      (enclosingNode.type === \"CallExpression\" &&\n        enclosingNode.arguments.length === 0))\n  ) {\n    addDanglingComment(enclosingNode, comment);\n    return true;\n  }\n  if (\n    enclosingNode &&\n    (enclosingNode.type === \"MethodDefinition\" &&\n      enclosingNode.value.params.length === 0)\n  ) {\n    addDanglingComment(enclosingNode.value, comment);\n    return true;\n  }\n  return false;\n}\n\nfunction handleLastFunctionArgComments(\n  text,\n  precedingNode,\n  enclosingNode,\n  followingNode,\n  comment\n) {\n  // Type definitions functions\n  if (\n    precedingNode &&\n    precedingNode.type === \"FunctionTypeParam\" &&\n    enclosingNode &&\n    enclosingNode.type === \"FunctionTypeAnnotation\" &&\n    followingNode &&\n    followingNode.type !== \"FunctionTypeParam\"\n  ) {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  // Real functions\n  if (\n    precedingNode &&\n    (precedingNode.type === \"Identifier\" ||\n      precedingNode.type === \"AssignmentPattern\") &&\n    enclosingNode &&\n    (enclosingNode.type === \"ArrowFunctionExpression\" ||\n      enclosingNode.type === \"FunctionExpression\" ||\n      enclosingNode.type === \"FunctionDeclaration\" ||\n      enclosingNode.type === \"ObjectMethod\" ||\n      enclosingNode.type === \"ClassMethod\") &&\n    getNextNonSpaceNonCommentCharacter(text, comment) === \")\"\n  ) {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n  return false;\n}\n\nfunction handleClassComments(enclosingNode, comment) {\n  if (\n    enclosingNode &&\n    (enclosingNode.type === \"ClassDeclaration\" ||\n      enclosingNode.type === \"ClassExpression\")\n  ) {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n  return false;\n}\n\nfunction handleImportSpecifierComments(enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"ImportSpecifier\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n  return false;\n}\n\nfunction handleObjectPropertyComments(enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"ObjectProperty\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n  return false;\n}\n\nfunction handleLabeledStatementComments(enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"LabeledStatement\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n  return false;\n}\n\nfunction handleCallExpressionComments(precedingNode, enclosingNode, comment) {\n  if (\n    enclosingNode &&\n    enclosingNode.type === \"CallExpression\" &&\n    precedingNode &&\n    enclosingNode.callee === precedingNode &&\n    enclosingNode.arguments.length > 0\n  ) {\n    addLeadingComment(enclosingNode.arguments[0], comment);\n    return true;\n  }\n  return false;\n}\n\nfunction handleUnionTypeComments(\n  precedingNode,\n  enclosingNode,\n  followingNode,\n  comment\n) {\n  if (enclosingNode && enclosingNode.type === \"UnionTypeAnnotation\") {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n  return false;\n}\n\nfunction handlePropertyComments(enclosingNode, comment) {\n  if (\n    enclosingNode &&\n    (enclosingNode.type === \"Property\" ||\n      enclosingNode.type === \"ObjectProperty\")\n  ) {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n  return false;\n}\n\nfunction handleExportNamedDeclarationComments(enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"ExportNamedDeclaration\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n  return false;\n}\n\nfunction handleOnlyComments(enclosingNode, ast, comment, isLastComment) {\n  // With Flow the enclosingNode is undefined so use the AST instead.\n  if (ast && ast.body && ast.body.length === 0) {\n    if (isLastComment) {\n      addDanglingComment(ast, comment);\n    } else {\n      addLeadingComment(ast, comment);\n    }\n    return true;\n  } else if (\n    enclosingNode &&\n    enclosingNode.type === \"Program\" &&\n    enclosingNode.body.length === 0 &&\n    enclosingNode.directives &&\n    enclosingNode.directives.length === 0\n  ) {\n    if (isLastComment) {\n      addDanglingComment(enclosingNode, comment);\n    } else {\n      addLeadingComment(enclosingNode, comment);\n    }\n    return true;\n  }\n  return false;\n}\n\nfunction handleForComments(enclosingNode, precedingNode, comment) {\n  if (\n    enclosingNode &&\n    (enclosingNode.type === \"ForInStatement\" ||\n      enclosingNode.type === \"ForOfStatement\")\n  ) {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n  return false;\n}\n\nfunction handleImportDeclarationComments(\n  enclosingNode,\n  precedingNode,\n  comment\n) {\n  if (\n    precedingNode &&\n    enclosingNode &&\n    enclosingNode.type === \"ImportDeclaration\" &&\n    comment.type !== \"CommentBlock\" &&\n    comment.type !== \"Block\"\n  ) {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n  return false;\n}\n\nfunction handleAssignmentPatternComments(enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"AssignmentPattern\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n  return false;\n}\n\nfunction handleClassMethodComments(enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"ClassMethod\") {\n    addTrailingComment(enclosingNode, comment);\n    return true;\n  }\n  return false;\n}\n\nfunction handleTypeAliasComments(enclosingNode, followingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"TypeAlias\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n  return false;\n}\n\nfunction handleVariableDeclaratorComments(\n  enclosingNode,\n  followingNode,\n  comment\n) {\n  if (\n    enclosingNode &&\n    enclosingNode.type === \"VariableDeclarator\" &&\n    followingNode &&\n    (followingNode.type === \"ObjectExpression\" ||\n      followingNode.type === \"ArrayExpression\")\n  ) {\n    addLeadingComment(followingNode, comment);\n    return true;\n  }\n  return false;\n}\n\nfunction printComment(commentPath) {\n  const comment = commentPath.getValue();\n  comment.printed = true;\n\n  switch (comment.type) {\n    case \"CommentBlock\":\n    case \"Block\":\n      return \"/*\" + comment.value + \"*/\";\n    case \"CommentLine\":\n    case \"Line\":\n      return \"//\" + comment.value;\n    default:\n      throw new Error(\"Not a comment: \" + JSON.stringify(comment));\n  }\n}\n\nfunction findExpressionIndexForComment(quasis, comment) {\n  const startPos = locStart(comment) - 1;\n\n  for (let i = 1; i < quasis.length; ++i) {\n    if (startPos < getQuasiRange(quasis[i]).start) {\n      return i - 1;\n    }\n  }\n\n  // We haven't found it, it probably means that some of the locations are off.\n  // Let's just return the first one.\n  return 0;\n}\n\nfunction getQuasiRange(expr) {\n  if (expr.start !== undefined) {\n    // Babylon\n    return { start: expr.start, end: expr.end };\n  }\n  // Flow\n  return { start: expr.range[0], end: expr.range[1] };\n}\n\nfunction printLeadingComment(commentPath, print, options) {\n  const comment = commentPath.getValue();\n  const contents = printComment(commentPath);\n  const text = options.originalText;\n  const isBlock = comment.type === \"Block\" || comment.type === \"CommentBlock\";\n\n  // Leading block comments should see if they need to stay on the\n  // same line or not.\n  if (isBlock) {\n    return concat([\n      contents,\n      util.hasNewline(options.originalText, locEnd(comment)) ? hardline : \" \"\n    ]);\n  }\n\n  return concat([contents, hardline]);\n}\n\nfunction printTrailingComment(commentPath, print, options, parentNode) {\n  const comment = commentPath.getValue();\n  const contents = printComment(commentPath);\n  const isBlock = comment.type === \"Block\" || comment.type === \"CommentBlock\";\n\n  if (\n    util.hasNewline(options.originalText, locStart(comment), {\n      backwards: true\n    })\n  ) {\n    // This allows comments at the end of nested structures:\n    // {\n    //   x: 1,\n    //   y: 2\n    //   // A comment\n    // }\n    // Those kinds of comments are almost always leading comments, but\n    // here it doesn't go \"outside\" the block and turns it into a\n    // trailing comment for `2`. We can simulate the above by checking\n    // if this a comment on its own line; normal trailing comments are\n    // always at the end of another expression.\n\n    const isLineBeforeEmpty = util.isPreviousLineEmpty(\n      options.originalText,\n      comment\n    );\n\n    return lineSuffix(\n      concat([hardline, isLineBeforeEmpty ? hardline : \"\", contents])\n    );\n  } else if (isBlock) {\n    // Trailing block comments never need a newline\n    return concat([\" \", contents]);\n  }\n\n  return concat([lineSuffix(\" \" + contents), !isBlock ? breakParent : \"\"]);\n}\n\nfunction printDanglingComments(path, options, sameIndent) {\n  const text = options.originalText;\n  const parts = [];\n  const node = path.getValue();\n\n  if (!node || !node.comments) {\n    return \"\";\n  }\n\n  path.each(commentPath => {\n    const comment = commentPath.getValue();\n    if (!comment.leading && !comment.trailing) {\n      parts.push(printComment(commentPath));\n    }\n  }, \"comments\");\n\n  if (parts.length === 0) {\n    return \"\";\n  }\n\n  if (sameIndent) {\n    return join(hardline, parts);\n  }\n  return indent(concat([hardline, join(hardline, parts)]));\n}\n\nfunction printComments(path, print, options, needsSemi) {\n  var value = path.getValue();\n  var parent = path.getParentNode();\n  var printed = print(path);\n  var comments = n.Node.check(value) && types.getFieldValue(value, \"comments\");\n\n  if (!comments || comments.length === 0) {\n    return printed;\n  }\n\n  var leadingParts = [];\n  var trailingParts = [needsSemi ? \";\" : \"\", printed];\n\n  path.each(function(commentPath) {\n    var comment = commentPath.getValue();\n    var leading = types.getFieldValue(comment, \"leading\");\n    var trailing = types.getFieldValue(comment, \"trailing\");\n\n    if (leading) {\n      leadingParts.push(printLeadingComment(commentPath, print, options));\n\n      const text = options.originalText;\n      if (util.hasNewline(text, util.skipNewline(text, util.locEnd(comment)))) {\n        leadingParts.push(hardline);\n      }\n    } else if (trailing) {\n      trailingParts.push(\n        printTrailingComment(commentPath, print, options, parent)\n      );\n    }\n  }, \"comments\");\n\n  return concat(leadingParts.concat(trailingParts));\n}\n\nmodule.exports = { attach, printComments, printDanglingComments };\n","/home/travis/build/npmtest/node-npmtest-prettier/node_modules/prettier/src/doc-builders.js":"\"use strict\";\n\nconst utils = require(\"./doc-utils\");\nconst willBreak = utils.willBreak;\n\nfunction assertDoc(val) {\n  if (\n    !(typeof val === \"string\" || (val != null && typeof val.type === \"string\"))\n  ) {\n    throw new Error(\n      \"Value \" + JSON.stringify(val) + \" is not a valid document\"\n    );\n  }\n}\n\nfunction concat(parts) {\n  parts.forEach(assertDoc);\n\n  // We cannot do this until we change `printJSXElement` to not\n  // access the internals of a document directly.\n  // if(parts.length === 1) {\n  //   // If it's a single document, no need to concat it.\n  //   return parts[0];\n  // }\n  return { type: \"concat\", parts };\n}\n\nfunction indent(contents) {\n  assertDoc(contents);\n\n  return { type: \"indent\", contents };\n}\n\nfunction align(n, contents) {\n  assertDoc(contents);\n\n  return { type: \"align\", contents, n };\n}\n\nfunction group(contents, opts) {\n  opts = opts || {};\n\n  assertDoc(contents);\n\n  return {\n    type: \"group\",\n    contents: contents,\n    break: !!opts.shouldBreak,\n    expandedStates: opts.expandedStates\n  };\n}\n\nfunction conditionalGroup(states, opts) {\n  return group(\n    states[0],\n    Object.assign(opts || {}, { expandedStates: states })\n  );\n}\n\nfunction ifBreak(breakContents, flatContents) {\n  if (breakContents) {\n    assertDoc(breakContents);\n  }\n  if (flatContents) {\n    assertDoc(flatContents);\n  }\n\n  return { type: \"if-break\", breakContents, flatContents };\n}\n\nfunction lineSuffix(contents) {\n  assertDoc(contents);\n  return { type: \"line-suffix\", contents };\n}\n\nconst lineSuffixBoundary = { type: \"line-suffix-boundary\" };\nconst breakParent = { type: \"break-parent\" };\nconst line = { type: \"line\" };\nconst softline = { type: \"line\", soft: true };\nconst hardline = concat([{ type: \"line\", hard: true }, breakParent]);\nconst literalline = concat([\n  { type: \"line\", hard: true, literal: true },\n  breakParent\n]);\n\nfunction join(sep, arr) {\n  var res = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (i !== 0) {\n      res.push(sep);\n    }\n\n    res.push(arr[i]);\n  }\n\n  return concat(res);\n}\n\nmodule.exports = {\n  concat,\n  join,\n  line,\n  softline,\n  hardline,\n  literalline,\n  group,\n  conditionalGroup,\n  lineSuffix,\n  lineSuffixBoundary,\n  breakParent,\n  ifBreak,\n  indent,\n  align\n};\n","/home/travis/build/npmtest/node-npmtest-prettier/node_modules/prettier/src/doc-utils.js":"\"use strict\";\n\nfunction traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {\n  function traverseDocRec(doc) {\n    var shouldRecurse = true;\n    if (onEnter) {\n      if (onEnter(doc) === false) {\n        shouldRecurse = false;\n      }\n    }\n\n    if (shouldRecurse) {\n      if (doc.type === \"concat\") {\n        for (var i = 0; i < doc.parts.length; i++) {\n          traverseDocRec(doc.parts[i]);\n        }\n      } else if (doc.type === \"if-break\") {\n        if (doc.breakContents) {\n          traverseDocRec(doc.breakContents);\n        }\n        if (doc.flatContents) {\n          traverseDocRec(doc.flatContents);\n        }\n      } else if (doc.type === \"group\" && doc.expandedStates) {\n        if (shouldTraverseConditionalGroups) {\n          doc.expandedStates.forEach(traverseDocRec);\n        } else {\n          traverseDocRec(doc.contents);\n        }\n      } else if (doc.contents) {\n        traverseDocRec(doc.contents);\n      }\n    }\n\n    if (onExit) {\n      onExit(doc);\n    }\n  }\n\n  traverseDocRec(doc);\n}\n\nfunction mapDoc(doc, func) {\n  doc = func(doc);\n\n  if (doc.type === \"concat\") {\n    return Object.assign({}, doc, {\n      parts: doc.parts.map(d => mapDoc(d, func))\n    });\n  } else if (doc.type === \"if-break\") {\n    return Object.assign({}, doc, {\n      breakContents: doc.breakContents && mapDoc(doc.breakContents, func),\n      flatContents: doc.flatContents && mapDoc(doc.flatContents, func)\n    });\n  } else if (doc.contents) {\n    return Object.assign({}, doc, { contents: mapDoc(doc.contents, func) });\n  } else {\n    return doc;\n  }\n}\n\nfunction findInDoc(doc, fn, defaultValue) {\n  var result = defaultValue;\n  var hasStopped = false;\n  traverseDoc(doc, function(doc) {\n    var maybeResult = fn(doc);\n    if (maybeResult !== undefined) {\n      hasStopped = true;\n      result = maybeResult;\n    }\n    if (hasStopped) {\n      return false;\n    }\n  });\n  return result;\n}\n\nfunction isEmpty(n) {\n  return typeof n === \"string\" && n.length === 0;\n}\n\nfunction isLineNext(doc) {\n  return findInDoc(\n    doc,\n    doc => {\n      if (typeof doc === \"string\") {\n        return false;\n      }\n      if (doc.type === \"line\") {\n        return true;\n      }\n    },\n    false\n  );\n}\n\nfunction willBreak(doc) {\n  return findInDoc(\n    doc,\n    doc => {\n      if (doc.type === \"group\" && doc.break) {\n        return true;\n      }\n      if (doc.type === \"line\" && doc.hard) {\n        return true;\n      }\n      if (doc.type === \"break-parent\") {\n        return true;\n      }\n    },\n    false\n  );\n}\n\nfunction breakParentGroup(groupStack) {\n  if (groupStack.length > 0) {\n    const parentGroup = groupStack[groupStack.length - 1];\n    // Breaks are not propagated through conditional groups because\n    // the user is expected to manually handle what breaks.\n    if (!parentGroup.expandedStates) {\n      parentGroup.break = true;\n    }\n  }\n  return null;\n}\n\nfunction propagateBreaks(doc) {\n  var alreadyVisited = new Map();\n  const groupStack = [];\n  traverseDoc(\n    doc,\n    doc => {\n      if (doc.type === \"break-parent\") {\n        breakParentGroup(groupStack);\n      }\n      if (doc.type === \"group\") {\n        groupStack.push(doc);\n        if (alreadyVisited.has(doc)) {\n          return false;\n        }\n        alreadyVisited.set(doc, true);\n      }\n    },\n    doc => {\n      if (doc.type === \"group\") {\n        const group = groupStack.pop();\n        if (group.break) {\n          breakParentGroup(groupStack);\n        }\n      }\n    },\n    /* shouldTraverseConditionalGroups */ true\n  );\n}\n\nmodule.exports = {\n  isEmpty,\n  willBreak,\n  isLineNext,\n  traverseDoc,\n  mapDoc,\n  propagateBreaks\n};\n","/home/travis/build/npmtest/node-npmtest-prettier/node_modules/prettier/src/util.js":"\"use strict\";\n\nvar types = require(\"ast-types\");\nvar n = types.namedTypes;\n\nfunction isExportDeclaration(node) {\n  if (node)\n    switch (node.type) {\n      case \"ExportDeclaration\":\n      case \"ExportDefaultDeclaration\":\n      case \"ExportDefaultSpecifier\":\n      case \"DeclareExportDeclaration\":\n      case \"ExportNamedDeclaration\":\n      case \"ExportAllDeclaration\":\n        return true;\n    }\n\n  return false;\n}\n\nfunction getParentExportDeclaration(path) {\n  var parentNode = path.getParentNode();\n  if (path.getName() === \"declaration\" && isExportDeclaration(parentNode)) {\n    return parentNode;\n  }\n\n  return null;\n}\n\nfunction getPenultimate(arr) {\n  if (arr.length > 1) {\n    return arr[arr.length - 2];\n  }\n  return null;\n}\n\nfunction getLast(arr) {\n  if (arr.length > 0) {\n    return arr[arr.length - 1];\n  }\n  return null;\n}\n\nfunction skip(chars) {\n  return (text, index, opts) => {\n    const backwards = opts && opts.backwards;\n\n    // Allow `skip` functions to be threaded together without having\n    // to check for failures (did someone say monads?).\n    if (index === false) {\n      return false;\n    }\n\n    const length = text.length;\n    let cursor = index;\n    while (cursor >= 0 && cursor < length) {\n      const c = text.charAt(cursor);\n      if (chars instanceof RegExp) {\n        if (!chars.test(c)) {\n          return cursor;\n        }\n      } else if (chars.indexOf(c) === -1) {\n        return cursor;\n      }\n\n      backwards ? cursor-- : cursor++;\n    }\n\n    if (cursor === -1 || cursor === length) {\n      // If we reached the beginning or end of the file, return the\n      // out-of-bounds cursor. It's up to the caller to handle this\n      // correctly. We don't want to indicate `false` though if it\n      // actually skipped valid characters.\n      return cursor;\n    }\n    return false;\n  };\n}\n\nconst skipWhitespace = skip(/\\s/);\nconst skipSpaces = skip(\" \\t\");\nconst skipToLineEnd = skip(\",; \\t\");\nconst skipEverythingButNewLine = skip(/[^\\r\\n]/);\n\nfunction skipInlineComment(text, index) {\n  if (index === false) {\n    return false;\n  }\n\n  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"*\") {\n    for (var i = index + 2; i < text.length; ++i) {\n      if (text.charAt(i) === \"*\" && text.charAt(i + 1) === \"/\") {\n        return i + 2;\n      }\n    }\n  }\n  return index;\n}\n\nfunction skipTrailingComment(text, index) {\n  if (index === false) {\n    return false;\n  }\n\n  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"/\") {\n    return skipEverythingButNewLine(text, index);\n  }\n  return index;\n}\n\n// This one doesn't use the above helper function because it wants to\n// test \\r\\n in order and `skip` doesn't support ordering and we only\n// want to skip one newline. It's simple to implement.\nfunction skipNewline(text, index, opts) {\n  const backwards = opts && opts.backwards;\n  if (index === false) {\n    return false;\n  }\n\n  const atIndex = text.charAt(index);\n  if (backwards) {\n    if (text.charAt(index - 1) === \"\\r\" && atIndex === \"\\n\") {\n      return index - 2;\n    }\n    if (\n      atIndex === \"\\n\" ||\n      atIndex === \"\\r\" ||\n      atIndex === \"\\u2028\" ||\n      atIndex === \"\\u2029\"\n    ) {\n      return index - 1;\n    }\n  } else {\n    if (atIndex === \"\\r\" && text.charAt(index + 1) === \"\\n\") {\n      return index + 2;\n    }\n    if (\n      atIndex === \"\\n\" ||\n      atIndex === \"\\r\" ||\n      atIndex === \"\\u2028\" ||\n      atIndex === \"\\u2029\"\n    ) {\n      return index + 1;\n    }\n  }\n\n  return index;\n}\n\nfunction hasNewline(text, index, opts) {\n  opts = opts || {};\n  const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);\n  const idx2 = skipNewline(text, idx, opts);\n  return idx !== idx2;\n}\n\nfunction hasNewlineInRange(text, start, end) {\n  for (var i = start; i < end; ++i) {\n    if (text.charAt(i) === \"\\n\") {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Note: this function doesn't ignore leading comments unlike isNextLineEmpty\nfunction isPreviousLineEmpty(text, node) {\n  let idx = locStart(node) - 1;\n  idx = skipSpaces(text, idx, { backwards: true });\n  idx = skipNewline(text, idx, { backwards: true });\n  idx = skipSpaces(text, idx, { backwards: true });\n  const idx2 = skipNewline(text, idx, { backwards: true });\n  return idx !== idx2;\n}\n\nfunction isNextLineEmpty(text, node) {\n  let oldIdx = null;\n  let idx = locEnd(node);\n  while (idx !== oldIdx) {\n    // We need to skip all the potential trailing inline comments\n    oldIdx = idx;\n    idx = skipToLineEnd(text, idx);\n    idx = skipInlineComment(text, idx);\n    idx = skipSpaces(text, idx);\n  }\n  idx = skipTrailingComment(text, idx);\n  idx = skipNewline(text, idx);\n  return hasNewline(text, idx);\n}\n\nfunction getNextNonSpaceNonCommentCharacter(text, node) {\n  let oldIdx = null;\n  let idx = locEnd(node);\n  while (idx !== oldIdx) {\n    oldIdx = idx;\n    idx = skipSpaces(text, idx);\n    idx = skipInlineComment(text, idx);\n    idx = skipTrailingComment(text, idx);\n    idx = skipNewline(text, idx);\n  }\n  return text.charAt(idx);\n}\n\nfunction hasSpaces(text, index, opts) {\n  opts = opts || {};\n  const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);\n  return idx !== index;\n}\n\nfunction locStart(node) {\n  if (node.range) {\n    return node.range[0];\n  }\n  return node.start;\n}\n\nfunction locEnd(node) {\n  if (node.range) {\n    return node.range[1];\n  }\n  return node.end;\n}\n\nfunction setLocStart(node, index) {\n  if (node.range) {\n    node.range[0] = index;\n  } else {\n    node.start = index;\n  }\n}\n\nfunction setLocEnd(node, index) {\n  if (node.range) {\n    node.range[1] = index;\n  } else {\n    node.end = index;\n  }\n}\n\n// http://stackoverflow.com/a/7124052\nfunction htmlEscapeInsideAngleBracket(str) {\n  return str.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n  // Intentionally disable the following since it is safe inside of a\n  // angle bracket context\n  //    .replace(/&/g, '&amp;')\n  //    .replace(/\"/g, '&quot;')\n  //    .replace(/'/g, '&#39;')\n}\n\nvar PRECEDENCE = {};\n[\n  [\"||\"],\n  [\"&&\"],\n  [\"|\"],\n  [\"^\"],\n  [\"&\"],\n  [\"==\", \"===\", \"!=\", \"!==\"],\n  [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n  [\">>\", \"<<\", \">>>\"],\n  [\"+\", \"-\"],\n  [\"*\", \"/\", \"%\"],\n  [\"**\"]\n].forEach(function(tier, i) {\n  tier.forEach(function(op) {\n    PRECEDENCE[op] = i;\n  });\n});\n\nfunction getPrecedence(op) {\n  return PRECEDENCE[op];\n}\n\nmodule.exports = {\n  getPrecedence,\n  isExportDeclaration,\n  getParentExportDeclaration,\n  getPenultimate,\n  getLast,\n  getNextNonSpaceNonCommentCharacter,\n  skipWhitespace,\n  skipSpaces,\n  skipNewline,\n  isNextLineEmpty,\n  isPreviousLineEmpty,\n  hasNewline,\n  hasNewlineInRange,\n  hasSpaces,\n  locStart,\n  locEnd,\n  setLocStart,\n  setLocEnd,\n  htmlEscapeInsideAngleBracket\n};\n","/home/travis/build/npmtest/node-npmtest-prettier/node_modules/prettier/src/printer.js":"\"use strict\";\n\nvar assert = require(\"assert\");\nvar comments = require(\"./comments\");\nvar FastPath = require(\"./fast-path\");\nvar util = require(\"./util\");\nvar isIdentifierName = require(\"esutils\").keyword.isIdentifierNameES6;\n\nvar docBuilders = require(\"./doc-builders\");\nvar concat = docBuilders.concat;\nvar join = docBuilders.join;\nvar line = docBuilders.line;\nvar hardline = docBuilders.hardline;\nvar softline = docBuilders.softline;\nvar literalline = docBuilders.literalline;\nvar group = docBuilders.group;\nvar indent = docBuilders.indent;\nvar align = docBuilders.align;\nvar conditionalGroup = docBuilders.conditionalGroup;\nvar ifBreak = docBuilders.ifBreak;\nvar breakParent = docBuilders.breakParent;\nvar lineSuffixBoundary = docBuilders.lineSuffixBoundary;\n\nvar docUtils = require(\"./doc-utils\");\nvar willBreak = docUtils.willBreak;\nvar isLineNext = docUtils.isLineNext;\nvar isEmpty = docUtils.isEmpty;\n\nvar types = require(\"ast-types\");\nvar namedTypes = types.namedTypes;\nvar isString = types.builtInTypes.string;\nvar isObject = types.builtInTypes.object;\n\nfunction shouldPrintComma(options, level) {\n  level = level || \"es5\";\n\n  switch (options.trailingComma) {\n    case \"all\":\n      if (level === \"all\") {\n        return true;\n      }\n    case \"es5\":\n      if (level === \"es5\") {\n        return true;\n      }\n    case \"none\":\n    default:\n      return false;\n  }\n}\n\nfunction genericPrint(path, options, printPath, args) {\n  assert.ok(path instanceof FastPath);\n\n  var node = path.getValue();\n\n  // Escape hatch\n  if (\n    node &&\n    node.comments &&\n    node.comments.length > 0 &&\n    node.comments.some(comment => comment.value.trim() === \"prettier-ignore\")\n  ) {\n    return options.originalText.slice(util.locStart(node), util.locEnd(node));\n  }\n\n  var parts = [];\n  var needsParens = false;\n  var linesWithoutParens = genericPrintNoParens(path, options, printPath, args);\n\n  if (!node || isEmpty(linesWithoutParens)) {\n    return linesWithoutParens;\n  }\n\n  if (\n    node.decorators &&\n    node.decorators.length > 0 &&\n    // If the parent node is an export declaration, it will be\n    // responsible for printing node.decorators.\n    !util.getParentExportDeclaration(path)\n  ) {\n    const separator = node.decorators.length === 1 &&\n      (node.decorators[0].expression.type === \"Identifier\" ||\n        node.decorators[0].expression.type === \"MemberExpression\")\n      ? \" \"\n      : hardline;\n    path.each(function(decoratorPath) {\n      parts.push(printPath(decoratorPath), separator);\n    }, \"decorators\");\n  } else if (\n    util.isExportDeclaration(node) &&\n    node.declaration &&\n    node.declaration.decorators\n  ) {\n    // Export declarations are responsible for printing any decorators\n    // that logically apply to node.declaration.\n    path.each(\n      function(decoratorPath) {\n        parts.push(printPath(decoratorPath), line);\n      },\n      \"declaration\",\n      \"decorators\"\n    );\n  } else {\n    // Nodes with decorators can't have parentheses, so we can avoid\n    // computing path.needsParens() except in this case.\n    needsParens = path.needsParens();\n  }\n\n  if (node.type) {\n    // HACK: ASI prevention in no-semi mode relies on knowledge of whether\n    // or not a paren has been inserted (see `exprNeedsASIProtection()`).\n    // For now, we're just passing that information by mutating the AST here,\n    // but it would be nice to find a cleaner way to do this.\n    node.needsParens = needsParens;\n  }\n\n  if (needsParens) {\n    parts.unshift(\"(\");\n  }\n\n  parts.push(linesWithoutParens);\n\n  if (needsParens) {\n    parts.push(\")\");\n  }\n\n  return concat(parts);\n}\n\nfunction genericPrintNoParens(path, options, print, args) {\n  var n = path.getValue();\n  const semi = options.semi ? \";\" : \"\";\n\n  if (!n) {\n    return \"\";\n  }\n\n  if (typeof n === \"string\") {\n    return n;\n  }\n\n  // TODO: Investigate types that return not printable.\n  // This assert isn't very useful though.\n  // namedTypes.Printable.assert(n);\n\n  var parts = [];\n  switch (n.type) {\n    case \"File\":\n      return path.call(print, \"program\");\n    case \"Program\":\n      // Babel 6\n      if (n.directives) {\n        path.each(function(childPath) {\n          parts.push(print(childPath), semi, hardline);\n          if (\n            util.isNextLineEmpty(options.originalText, childPath.getValue())\n          ) {\n            parts.push(hardline);\n          }\n        }, \"directives\");\n      }\n\n      parts.push(\n        path.call(function(bodyPath) {\n          return printStatementSequence(bodyPath, options, print);\n        }, \"body\")\n      );\n\n      parts.push(\n        comments.printDanglingComments(path, options, /* sameIndent */ true)\n      );\n\n      // Only force a trailing newline if there were any contents.\n      if (n.body.length || n.comments) {\n        parts.push(hardline);\n      }\n\n      return concat(parts);\n    // Babel extension.\n    case \"Noop\":\n    case \"EmptyStatement\":\n      return \"\";\n    case \"ExpressionStatement\":\n      return concat([path.call(print, \"expression\"), semi]); // Babel extension.\n    case \"ParenthesizedExpression\":\n      return concat([\"(\", path.call(print, \"expression\"), \")\"]);\n    case \"AssignmentExpression\":\n      return printAssignment(\n        n.left,\n        path.call(print, \"left\"),\n        n.operator,\n        n.right,\n        path.call(print, \"right\"),\n        options\n      );\n    case \"BinaryExpression\":\n    case \"LogicalExpression\": {\n      const parent = path.getParentNode();\n      const isInsideParenthesis =\n        n !== parent.body &&\n        (parent.type === \"IfStatement\" ||\n          parent.type === \"WhileStatement\" ||\n          parent.type === \"DoStatement\");\n\n      const parts = printBinaryishExpressions(\n        path,\n        print,\n        options,\n        /* isNested */ false,\n        isInsideParenthesis\n      );\n\n      //   if (\n      //     this.hasPlugin(\"dynamicImports\") && this.lookahead().type === tt.parenLeft\n      //   ) {\n      //\n      // looks super weird, we want to break the children if the parent breaks\n      //\n      //   if (\n      //     this.hasPlugin(\"dynamicImports\") &&\n      //     this.lookahead().type === tt.parenLeft\n      //   ) {\n      if (isInsideParenthesis) {\n        return concat(parts);\n      }\n\n      // Avoid indenting sub-expressions in assignment/return/etc statements.\n      if (\n        parent.type === \"AssignmentExpression\" ||\n        parent.type === \"VariableDeclarator\" ||\n        shouldInlineLogicalExpression(n) ||\n        parent.type === \"ReturnStatement\" ||\n        (n === parent.body && parent.type === \"ArrowFunctionExpression\") ||\n        (n !== parent.body && parent.type === \"ForStatement\")\n      ) {\n        return group(concat(parts));\n      }\n\n      const rest = concat(parts.slice(1));\n\n      return group(\n        concat([\n          // Don't include the initial expression in the indentation\n          // level. The first item is guaranteed to be the first\n          // left-most expression.\n          parts.length > 0 ? parts[0] : \"\",\n          indent(rest)\n        ])\n      );\n    }\n    case \"AssignmentPattern\":\n      return concat([\n        path.call(print, \"left\"),\n        \" = \",\n        path.call(print, \"right\")\n      ]);\n    case \"MemberExpression\": {\n      const parent = path.getParentNode();\n      let firstNonMemberParent;\n      let i = 0;\n      do {\n        firstNonMemberParent = path.getParentNode(i);\n        i++;\n      } while (\n        firstNonMemberParent &&\n        firstNonMemberParent.type === \"MemberExpression\"\n      );\n\n      const shouldInline =\n        firstNonMemberParent && (\n          (firstNonMemberParent.type === \"VariableDeclarator\" &&\n            firstNonMemberParent.id.type !== \"Identifier\") ||\n          (firstNonMemberParent.type === \"AssignmentExpression\" &&\n            firstNonMemberParent.left.type !== \"Identifier\")) ||\n        n.computed ||\n        (n.object.type === \"Identifier\" &&\n          n.property.type === \"Identifier\" &&\n          parent.type !== \"MemberExpression\");\n\n      return concat([\n        path.call(print, \"object\"),\n        shouldInline\n          ? printMemberLookup(path, options, print)\n          : group(\n              indent(\n                concat([softline, printMemberLookup(path, options, print)])\n              )\n            )\n      ]);\n    }\n    case \"MetaProperty\":\n      return concat([\n        path.call(print, \"meta\"),\n        \".\",\n        path.call(print, \"property\")\n      ]);\n    case \"BindExpression\":\n      if (n.object) {\n        parts.push(path.call(print, \"object\"));\n      }\n\n      parts.push(\"::\", path.call(print, \"callee\"));\n\n      return concat(parts);\n    case \"Path\":\n      return join(\".\", n.body);\n    case \"Identifier\":\n      return concat([\n        n.name,\n        n.optional ? \"?\" : \"\",\n        path.call(print, \"typeAnnotation\")\n      ]);\n    case \"SpreadElement\":\n    case \"SpreadElementPattern\":\n    // Babel 6 for ObjectPattern\n    case \"RestProperty\":\n    case \"SpreadProperty\":\n    case \"SpreadPropertyPattern\":\n    case \"RestElement\":\n    case \"ObjectTypeSpreadProperty\":\n      return concat([\n        \"...\",\n        path.call(print, \"argument\"),\n        path.call(print, \"typeAnnotation\")\n      ]);\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      return printFunctionDeclaration(path, print, options);\n    case \"ArrowFunctionExpression\": {\n      if (n.async) parts.push(\"async \");\n\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n\n      if (canPrintParamsWithoutParens(n)) {\n        parts.push(path.call(print, \"params\", 0));\n      } else {\n        parts.push(\n          group(\n            concat([\n              printFunctionParams(\n                path,\n                print,\n                options,\n                args && (args.expandLastArg || args.expandFirstArg)\n              ),\n              printReturnType(path, print)\n            ])\n          )\n        );\n      }\n\n      parts.push(\" =>\");\n\n      const body = path.call(print, \"body\");\n      const collapsed = concat([concat(parts), \" \", body]);\n\n      // We want to always keep these types of nodes on the same line\n      // as the arrow.\n      if (\n        n.body.type === \"ArrayExpression\" ||\n        n.body.type === \"ObjectExpression\" ||\n        n.body.type === \"JSXElement\" ||\n        n.body.type === \"BlockStatement\" ||\n        n.body.type === \"TaggedTemplateExpression\" ||\n        n.body.type === \"TemplateElement\" ||\n        n.body.type === \"ClassExpression\" ||\n        n.body.type === \"ArrowFunctionExpression\"\n      ) {\n        return group(collapsed);\n      }\n\n      // if the arrow function is expanded as last argument, we are adding a\n      // level of indentation and need to add a softline to align the closing )\n      // with the opening (.\n      const shouldAddSoftLine = args && args.expandLastArg;\n\n      return group(\n        concat([\n          concat(parts),\n          group(\n            concat([\n              indent(concat([line, body])),\n              shouldAddSoftLine\n                ? concat([\n                    ifBreak(shouldPrintComma(options, \"all\") ? \",\" : \"\"),\n                    softline\n                  ])\n                : \"\"\n            ])\n          )\n        ])\n      );\n    }\n    case \"MethodDefinition\":\n      if (n.static) {\n        parts.push(\"static \");\n      }\n\n      parts.push(printMethod(path, options, print));\n\n      return concat(parts);\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n\n      if (n.delegate) parts.push(\"*\");\n\n      if (n.argument) parts.push(\" \", path.call(print, \"argument\"));\n\n      return concat(parts);\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n\n      if (n.all) parts.push(\"*\");\n\n      if (n.argument) parts.push(\" \", path.call(print, \"argument\"));\n\n      return concat(parts);\n    case \"ModuleDeclaration\":\n      parts.push(\"module\", path.call(print, \"id\"));\n\n      if (n.source) {\n        assert.ok(!n.body);\n\n        parts.push(\"from\", path.call(print, \"source\"));\n      } else {\n        parts.push(path.call(print, \"body\"));\n      }\n\n      return join(\" \", parts);\n    case \"ImportSpecifier\":\n      if (n.imported) {\n        if (n.importKind) {\n          parts.push(path.call(print, \"importKind\"), \" \");\n        }\n\n        parts.push(path.call(print, \"imported\"));\n\n        if (n.local && n.local.name !== n.imported.name) {\n          parts.push(\" as \", path.call(print, \"local\"));\n        }\n      } else if (n.id) {\n        parts.push(path.call(print, \"id\"));\n\n        if (n.name) {\n          parts.push(\" as \", path.call(print, \"name\"));\n        }\n      }\n\n      return concat(parts);\n    case \"ExportSpecifier\":\n      if (n.local) {\n        parts.push(path.call(print, \"local\"));\n\n        if (n.exported && n.exported.name !== n.local.name) {\n          parts.push(\" as \", path.call(print, \"exported\"));\n        }\n      } else if (n.id) {\n        parts.push(path.call(print, \"id\"));\n\n        if (n.name) {\n          parts.push(\" as \", path.call(print, \"name\"));\n        }\n      }\n\n      return concat(parts);\n    case \"ExportBatchSpecifier\":\n      return \"*\";\n    case \"ImportNamespaceSpecifier\":\n      parts.push(\"* as \");\n\n      if (n.local) {\n        parts.push(path.call(print, \"local\"));\n      } else if (n.id) {\n        parts.push(path.call(print, \"id\"));\n      }\n\n      return concat(parts);\n    case \"ImportDefaultSpecifier\":\n      if (n.local) {\n        return path.call(print, \"local\");\n      }\n\n      return path.call(print, \"id\");\n    case \"ExportDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n      return printExportDeclaration(path, options, print);\n    case \"ExportAllDeclaration\":\n      parts.push(\"export *\");\n\n      if (n.exported) {\n        parts.push(\" as \", path.call(print, \"exported\"));\n      }\n\n      parts.push(\" from \", path.call(print, \"source\"), semi);\n\n      return concat(parts);\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      return path.call(print, \"exported\");\n    case \"ImportDeclaration\":\n      parts.push(\"import \");\n\n      const fromParts = [];\n\n      if (n.importKind && n.importKind !== \"value\") {\n        parts.push(n.importKind + \" \");\n      }\n\n      var standalones = [];\n      var grouped = [];\n      if (n.specifiers && n.specifiers.length > 0) {\n        path.each(function(specifierPath) {\n          var value = specifierPath.getValue();\n          if (\n            namedTypes.ImportDefaultSpecifier.check(value) ||\n            namedTypes.ImportNamespaceSpecifier.check(value)\n          ) {\n            standalones.push(print(specifierPath));\n          } else {\n            grouped.push(print(specifierPath));\n          }\n        }, \"specifiers\");\n\n        if (standalones.length > 0) {\n          parts.push(join(\", \", standalones));\n        }\n\n        if (standalones.length > 0 && grouped.length > 0) {\n          parts.push(\", \");\n        }\n\n        if (grouped.length > 0) {\n          parts.push(\n            group(\n              concat([\n                \"{\",\n                indent(\n                  concat([\n                    options.bracketSpacing ? line : softline,\n                    join(concat([\",\", line]), grouped)\n                  ])\n                ),\n                ifBreak(shouldPrintComma(options) ? \",\" : \"\"),\n                options.bracketSpacing ? line : softline,\n                \"}\"\n              ])\n            )\n          );\n        }\n\n        fromParts.push(grouped.length === 0 ? line : \" \", \"from \");\n      } else if (n.importKind && n.importKind === \"type\") {\n        parts.push(\"{} from \");\n      }\n\n      fromParts.push(path.call(print, \"source\"), semi);\n\n      // If there's a very long import, break the following way:\n      //\n      //   import veryLong\n      //     from 'verylong'\n      //\n      // In case there are grouped elements, they will already break the way\n      // we want and this break would take precedence instead.\n      if (grouped.length === 0) {\n        return group(concat([concat(parts), indent(concat(fromParts))]));\n      }\n\n      return concat([concat(parts), concat(fromParts)]);\n\n    case \"Import\": {\n      return \"import\";\n    }\n    case \"BlockStatement\": {\n      var naked = path.call(function(bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\");\n\n      const hasContent = n.body.find(node => node.type !== \"EmptyStatement\");\n      const hasDirectives = n.directives && n.directives.length > 0;\n\n      var parent = path.getParentNode();\n      const parentParent = path.getParentNode(1);\n      if (\n        !hasContent &&\n        !hasDirectives &&\n        !n.comments &&\n        (parent.type === \"ArrowFunctionExpression\" ||\n          parent.type === \"FunctionExpression\" ||\n          parent.type === \"FunctionDeclaration\" ||\n          parent.type === \"ObjectMethod\" ||\n          parent.type === \"ClassMethod\" ||\n          (parent.type === \"CatchClause\" && !parentParent.finalizer))\n      ) {\n        return \"{}\";\n      }\n\n      parts.push(\"{\");\n\n      // Babel 6\n      if (hasDirectives) {\n        path.each(function(childPath) {\n          parts.push(indent(concat([hardline, print(childPath), semi])));\n        }, \"directives\");\n      }\n\n      if (hasContent) {\n        parts.push(indent(concat([hardline, naked])));\n      }\n\n      parts.push(comments.printDanglingComments(path, options));\n      parts.push(hardline, \"}\");\n\n      return concat(parts);\n    }\n    case \"ReturnStatement\":\n      parts.push(\"return\");\n\n      if (n.argument) {\n        if (returnArgumentHasLeadingComment(options, n.argument)) {\n          parts.push(\n            concat([\n              \" (\",\n              indent(concat([softline, path.call(print, \"argument\")])),\n              line,\n              \")\"\n            ])\n          );\n        } else if (\n          n.argument.type === \"LogicalExpression\" ||\n          n.argument.type === \"BinaryExpression\"\n        ) {\n          parts.push(\n            group(\n              concat([\n                ifBreak(\" (\", \" \"),\n                indent(concat([softline, path.call(print, \"argument\")])),\n                softline,\n                ifBreak(\")\")\n              ])\n            )\n          );\n        } else {\n          parts.push(\" \", path.call(print, \"argument\"));\n        }\n      }\n\n      const hasDanglingComments =\n        n.comments &&\n        n.comments.some(comment => !comment.leading && !comment.trailing);\n\n      if (hasDanglingComments) {\n        parts.push(\n          \" \",\n          comments.printDanglingComments(path, options, /* sameIndent */ true)\n        );\n      }\n\n      parts.push(semi);\n\n      return concat(parts);\n    case \"CallExpression\": {\n      if (\n        // We want to keep require calls as a unit\n        (n.callee.type === \"Identifier\" && n.callee.name === \"require\") ||\n        // Keep test declarations on a single line\n        // e.g. `it('long name', () => {`\n        (n.callee.type === \"Identifier\" &&\n          (n.callee.name === \"it\" ||\n            n.callee.name === \"test\" ||\n            n.callee.name === \"describe\") &&\n          n.arguments.length === 2 &&\n          (n.arguments[0].type === \"StringLiteral\" ||\n            n.arguments[0].type === \"TemplateLiteral\" ||\n            (n.arguments[0].type === \"Literal\" &&\n              typeof n.arguments[0].value === \"string\")) &&\n          (n.arguments[1].type === \"FunctionExpression\" ||\n            n.arguments[1].type === \"ArrowFunctionExpression\") &&\n          n.arguments[1].params.length <= 1)\n      ) {\n        return concat([\n          path.call(print, \"callee\"),\n          path.call(print, \"typeParameters\"),\n          concat([\"(\", join(\", \", path.map(print, \"arguments\")), \")\"])\n        ]);\n      }\n\n      // We detect calls on member lookups and possibly print them in a\n      // special chain format. See `printMemberChain` for more info.\n      if (n.callee.type === \"MemberExpression\") {\n        return printMemberChain(path, options, print);\n      }\n\n      return concat([\n        path.call(print, \"callee\"),\n        path.call(print, \"typeParameters\"),\n        printArgumentsList(path, options, print)\n      ]);\n    }\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n    case \"ObjectTypeAnnotation\":\n    case \"TSTypeLiteral\":\n      var isTypeAnnotation = n.type === \"ObjectTypeAnnotation\";\n      var isTypeScriptTypeAnnotaion = n.type === \"TSTypeLiteral\";\n      // Leave this here because we *might* want to make this\n      // configurable later -- flow accepts \";\" for type separators,\n      // typescript accepts \";\" and newlines\n      var separator = isTypeAnnotation ? \",\" : \",\";\n      var fields = [];\n      var leftBrace = n.exact ? \"{|\" : \"{\";\n      var rightBrace = n.exact ? \"|}\" : \"}\";\n      var parent = path.getParentNode(0);\n      var parentIsUnionTypeAnnotation = parent.type === \"UnionTypeAnnotation\";\n      var propertiesField = isTypeScriptTypeAnnotaion\n        ? \"members\"\n        : \"properties\";\n\n      if (isTypeAnnotation) {\n        fields.push(\"indexers\", \"callProperties\");\n      }\n\n      fields.push(propertiesField);\n\n      var props = [];\n      let separatorParts = [];\n\n      fields.forEach(function(field) {\n        path.each(function(childPath) {\n          props.push(concat(separatorParts));\n          props.push(group(print(childPath)));\n\n          separatorParts = [separator, line];\n          if (\n            util.isNextLineEmpty(options.originalText, childPath.getValue())\n          ) {\n            separatorParts.push(hardline);\n          }\n        }, field);\n      });\n\n      const lastElem = util.getLast(n[propertiesField]);\n\n      const canHaveTrailingComma = !(\n        lastElem &&\n        (lastElem.type === \"RestProperty\" || lastElem.type === \"RestElement\")\n      );\n\n      const shouldBreak =\n        n.type !== \"ObjectPattern\" &&\n        util.hasNewlineInRange(\n          options.originalText,\n          util.locStart(n),\n          util.locEnd(n)\n        );\n\n      if (props.length === 0) {\n        return group(\n          concat([\n            leftBrace,\n            comments.printDanglingComments(path, options),\n            softline,\n            rightBrace\n          ])\n        );\n      } else {\n        return group(\n          concat([\n            leftBrace,\n            indent(\n              align(\n                parentIsUnionTypeAnnotation ? 2 : 0,\n                concat([\n                  options.bracketSpacing ? line : softline,\n                  concat(props)\n                ])\n              )\n            ),\n            ifBreak(\n              canHaveTrailingComma && shouldPrintComma(options) ? \",\" : \"\"\n            ),\n            align(\n              parentIsUnionTypeAnnotation ? 2 : 0,\n              concat([options.bracketSpacing ? line : softline, rightBrace])\n            ),\n            path.call(print, \"typeAnnotation\")\n          ]),\n          { shouldBreak }\n        );\n      }\n\n    case \"PropertyPattern\":\n      return concat([\n        path.call(print, \"key\"),\n        \": \",\n        path.call(print, \"pattern\")\n      ]);\n    // Babel 6\n    case \"ObjectProperty\": // Non-standard AST node type.\n    case \"Property\":\n      if (n.method || n.kind === \"get\" || n.kind === \"set\") {\n        return printMethod(path, options, print);\n      }\n\n      if (n.shorthand) {\n        parts.push(path.call(print, \"value\"));\n      } else {\n        if (n.computed) {\n          parts.push(\"[\", path.call(print, \"key\"), \"]\");\n        } else {\n          parts.push(printPropertyKey(path, options, print));\n        }\n        parts.push(concat([\": \", path.call(print, \"value\")]));\n      }\n\n      return concat(parts); // Babel 6\n    case \"ClassMethod\":\n      if (n.static) {\n        parts.push(\"static \");\n      }\n\n      parts = parts.concat(printObjectMethod(path, options, print));\n\n      return concat(parts); // Babel 6\n    case \"ObjectMethod\":\n      return printObjectMethod(path, options, print);\n    case \"Decorator\":\n      return concat([\"@\", path.call(print, \"expression\")]);\n    case \"ArrayExpression\":\n    case \"ArrayPattern\":\n      if (n.elements.length === 0) {\n        parts.push(\n          group(\n            concat([\n              \"[\",\n              comments.printDanglingComments(path, options),\n              softline,\n              \"]\"\n            ])\n          )\n        );\n      } else {\n        const lastElem = util.getLast(n.elements);\n        const canHaveTrailingComma = !(lastElem &&\n          lastElem.type === \"RestElement\");\n\n        // JavaScript allows you to have empty elements in an array which\n        // changes its length based on the number of commas. The algorithm\n        // is that if the last argument is null, we need to force insert\n        // a comma to ensure JavaScript recognizes it.\n        //   [,].length === 1\n        //   [1,].length === 1\n        //   [1,,].length === 2\n        //\n        // Note that util.getLast returns null if the array is empty, but\n        // we already check for an empty array just above so we are safe\n        const needsForcedTrailingComma =\n          canHaveTrailingComma && lastElem === null;\n\n        parts.push(\n          group(\n            concat([\n              \"[\",\n              indent(\n                concat([\n                  softline,\n                  printArrayItems(path, options, \"elements\", print)\n                ])\n              ),\n              needsForcedTrailingComma ? \",\" : \"\",\n              ifBreak(\n                canHaveTrailingComma &&\n                  !needsForcedTrailingComma &&\n                  shouldPrintComma(options)\n                  ? \",\"\n                  : \"\"\n              ),\n              comments.printDanglingComments(\n                path,\n                options,\n                /* sameIndent */ true\n              ),\n              softline,\n              \"]\"\n            ])\n          )\n        );\n      }\n\n      if (n.typeAnnotation) parts.push(path.call(print, \"typeAnnotation\"));\n\n      return concat(parts);\n    case \"SequenceExpression\":\n      return join(\", \", path.map(print, \"expressions\"));\n    case \"ThisExpression\":\n      return \"this\";\n    case \"Super\":\n      return \"super\";\n    // Babel 6 Literal split\n    case \"NullLiteral\":\n      return \"null\";\n    // Babel 6 Literal split\n    case \"RegExpLiteral\":\n      return printRegex(n);\n    // Babel 6 Literal split\n    case \"NumericLiteral\":\n      return printNumber(n.extra.raw);\n    // Babel 6 Literal split\n    case \"BooleanLiteral\":\n    // Babel 6 Literal split\n    case \"StringLiteral\":\n    case \"Literal\":\n      if (typeof n.value === \"number\") return printNumber(n.raw);\n      if (n.regex) return printRegex(n.regex);\n      if (typeof n.value !== \"string\") return \"\" + n.value;\n\n      return nodeStr(n, options); // Babel 6\n    case \"Directive\":\n      return path.call(print, \"value\"); // Babel 6\n    case \"DirectiveLiteral\":\n      return nodeStr(n, options);\n    case \"ModuleSpecifier\":\n      if (n.local) {\n        throw new Error(\"The ESTree ModuleSpecifier type should be abstract\");\n      }\n\n      // The Esprima ModuleSpecifier type is just a string-valued\n      // Literal identifying the imported-from module.\n      return nodeStr(n, options);\n    case \"UnaryExpression\":\n      parts.push(n.operator);\n\n      if (/[a-z]$/.test(n.operator)) parts.push(\" \");\n\n      parts.push(path.call(print, \"argument\"));\n\n      return concat(parts);\n    case \"UpdateExpression\":\n      parts.push(path.call(print, \"argument\"), n.operator);\n\n      if (n.prefix) parts.reverse();\n\n      return concat(parts);\n    case \"ConditionalExpression\":\n      return group(\n        concat([\n          path.call(print, \"test\"),\n          indent(\n            concat([\n              line,\n              \"? \",\n              align(2, path.call(print, \"consequent\")),\n              line,\n              \": \",\n              align(2, path.call(print, \"alternate\"))\n            ])\n          )\n        ])\n      );\n    case \"NewExpression\":\n      parts.push(\"new \", path.call(print, \"callee\"));\n\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n\n      var args = n.arguments;\n\n      if (args) {\n        parts.push(printArgumentsList(path, options, print));\n      }\n\n      return concat(parts);\n    case \"VariableDeclaration\":\n      var printed = path.map(function(childPath) {\n        return print(childPath);\n      }, \"declarations\");\n\n      parts = [\n        n.kind,\n        \" \",\n        printed[0],\n        indent(concat(printed.slice(1).map(p => concat([\",\", line, p]))))\n      ];\n\n      // We generally want to terminate all variable declarations with a\n      // semicolon, except when they in the () part of for loops.\n      var parentNode = path.getParentNode();\n\n      var isParentForLoop =\n        namedTypes.ForStatement.check(parentNode) ||\n        namedTypes.ForInStatement.check(parentNode) ||\n        (namedTypes.ForOfStatement &&\n          namedTypes.ForOfStatement.check(parentNode)) ||\n        (namedTypes.ForAwaitStatement &&\n          namedTypes.ForAwaitStatement.check(parentNode));\n\n      if (!(isParentForLoop && parentNode.body !== n)) {\n        parts.push(semi);\n      }\n\n      return group(concat(parts));\n    case \"VariableDeclarator\":\n      return printAssignment(\n        n.id,\n        path.call(print, \"id\"),\n        \"=\",\n        n.init,\n        n.init && path.call(print, \"init\"),\n        options\n      );\n    case \"WithStatement\":\n      return concat([\n        \"with (\",\n        path.call(print, \"object\"),\n        \")\",\n        adjustClause(n.body, path.call(print, \"body\"))\n      ]);\n    case \"IfStatement\":\n      const con = adjustClause(n.consequent, path.call(print, \"consequent\"));\n      const opening = group(\n        concat([\n          \"if (\",\n          group(\n            concat([\n              indent(concat([softline, path.call(print, \"test\")])),\n              softline\n            ])\n          ),\n          \")\",\n          con\n        ])\n      );\n\n      parts.push(opening);\n\n      if (n.alternate) {\n        if (n.consequent.type === \"BlockStatement\") {\n          parts.push(\" else\");\n        } else {\n          parts.push(hardline, \"else\");\n        }\n\n        parts.push(\n          group(\n            adjustClause(\n              n.alternate,\n              path.call(print, \"alternate\"),\n              n.alternate.type === \"IfStatement\"\n            )\n          )\n        );\n      }\n\n      return concat(parts);\n    case \"ForStatement\": {\n      const body = adjustClause(n.body, path.call(print, \"body\"));\n\n      // We want to keep dangling comments above the loop to stay consistent.\n      // Any comment positioned between the for statement and the parentheses\n      // is going to be printed before the statement.\n      const dangling = comments.printDanglingComments(\n        path,\n        options,\n        /* sameLine */ true\n      );\n      const printedComments = dangling ? concat([dangling, softline]) : \"\";\n\n      if (!n.init && !n.test && !n.update) {\n        return concat([printedComments, \"for (;;)\", body]);\n      }\n\n      return concat([\n        printedComments,\n        \"for (\",\n        group(\n          concat([\n            indent(\n              concat([\n                softline,\n                path.call(print, \"init\"),\n                \";\",\n                line,\n                path.call(print, \"test\"),\n                \";\",\n                line,\n                path.call(print, \"update\")\n              ])\n            ),\n            softline\n          ])\n        ),\n        \")\",\n        body\n      ]);\n    }\n    case \"WhileStatement\":\n      return concat([\n        \"while (\",\n        group(\n          concat([\n            indent(concat([softline, path.call(print, \"test\")])),\n            softline\n          ])\n        ),\n        \")\",\n        adjustClause(n.body, path.call(print, \"body\"))\n      ]);\n    case \"ForInStatement\":\n      // Note: esprima can't actually parse \"for each (\".\n      return concat([\n        n.each ? \"for each (\" : \"for (\",\n        path.call(print, \"left\"),\n        \" in \",\n        path.call(print, \"right\"),\n        \")\",\n        adjustClause(n.body, path.call(print, \"body\"))\n      ]);\n\n    case \"ForOfStatement\":\n    case \"ForAwaitStatement\":\n      // Babylon 7 removed ForAwaitStatement in favor of ForOfStatement\n      // with `\"await\": true`:\n      // https://github.com/estree/estree/pull/138\n      const isAwait = n.type === \"ForAwaitStatement\" || n.await;\n\n      return concat([\n        \"for\",\n        isAwait ? \" await\" : \"\",\n        \" (\",\n        path.call(print, \"left\"),\n        \" of \",\n        path.call(print, \"right\"),\n        \")\",\n        adjustClause(n.body, path.call(print, \"body\"))\n      ]);\n\n    case \"DoWhileStatement\":\n      var clause = adjustClause(n.body, path.call(print, \"body\"));\n      var doBody = concat([\"do\", clause]);\n      var parts = [doBody];\n\n      if (n.body.type === \"BlockStatement\") {\n        parts.push(\" \");\n      } else {\n        parts.push(hardline);\n      }\n      parts.push(\"while\");\n\n      parts.push(\" (\", path.call(print, \"test\"), \")\", semi);\n\n      return concat(parts);\n    case \"DoExpression\":\n      return concat([\"do \", path.call(print, \"body\")]);\n    case \"BreakStatement\":\n      parts.push(\"break\");\n\n      if (n.label) parts.push(\" \", path.call(print, \"label\"));\n\n      parts.push(semi);\n\n      return concat(parts);\n    case \"ContinueStatement\":\n      parts.push(\"continue\");\n\n      if (n.label) parts.push(\" \", path.call(print, \"label\"));\n\n      parts.push(semi);\n\n      return concat(parts);\n    case \"LabeledStatement\":\n      if (n.body.type === \"EmptyStatement\") {\n        return concat([path.call(print, \"label\"), \":;\"]);\n      }\n\n      return concat([\n        path.call(print, \"label\"),\n        \": \",\n        path.call(print, \"body\")\n      ]);\n    case \"TryStatement\":\n      parts.push(\"try \", path.call(print, \"block\"));\n\n      if (n.handler) {\n        parts.push(\" \", path.call(print, \"handler\"));\n      } else if (n.handlers) {\n        path.each(function(handlerPath) {\n          parts.push(\" \", print(handlerPath));\n        }, \"handlers\");\n      }\n\n      if (n.finalizer) {\n        parts.push(\" finally \", path.call(print, \"finalizer\"));\n      }\n\n      return concat(parts);\n    case \"CatchClause\":\n      parts.push(\"catch (\", path.call(print, \"param\"));\n\n      if (n.guard)\n        // Note: esprima does not recognize conditional catch clauses.\n        parts.push(\" if \", path.call(print, \"guard\"));\n\n      parts.push(\") \", path.call(print, \"body\"));\n\n      return concat(parts);\n    case \"ThrowStatement\":\n      return concat([\"throw \", path.call(print, \"argument\"), semi]);\n    // Note: ignoring n.lexical because it has no printing consequences.\n    case \"SwitchStatement\":\n      return concat([\n        \"switch (\",\n        path.call(print, \"discriminant\"),\n        \") {\",\n        n.cases.length > 0\n          ? indent(concat([hardline, join(hardline, path.map(print, \"cases\"))]))\n          : \"\",\n        hardline,\n        \"}\"\n      ]);\n    case \"SwitchCase\":\n      if (n.test) parts.push(\"case \", path.call(print, \"test\"), \":\");\n      else parts.push(\"default:\");\n\n      const isFirstCase = path.getNode() === path.getParentNode().cases[0];\n\n      if (\n        !isFirstCase &&\n        util.isPreviousLineEmpty(options.originalText, path.getValue())\n      ) {\n        parts.unshift(hardline);\n      }\n\n      if (n.consequent.find(node => node.type !== \"EmptyStatement\")) {\n        const cons = path.call(consequentPath => {\n          return join(\n            hardline,\n            consequentPath\n              .map((p, i) => {\n                if (n.consequent[i].type === \"EmptyStatement\") {\n                  return null;\n                }\n                const shouldAddLine =\n                  i !== n.consequent.length - 1 &&\n                  util.isNextLineEmpty(options.originalText, p.getValue());\n                return concat([print(p), shouldAddLine ? hardline : \"\"]);\n              })\n              .filter(e => e !== null)\n          );\n        }, \"consequent\");\n        parts.push(\n          n.consequent.length === 1 && n.consequent[0].type === \"BlockStatement\"\n            ? concat([\" \", cons])\n            : indent(concat([hardline, cons]))\n        );\n      }\n\n      return concat(parts);\n    // JSX extensions below.\n    case \"DebuggerStatement\":\n      return concat([\"debugger\", semi]);\n    case \"JSXAttribute\":\n      parts.push(path.call(print, \"name\"));\n\n      if (n.value) {\n        let res;\n        if (\n          (n.value.type === \"StringLiteral\" || n.value.type === \"Literal\") &&\n          typeof n.value.value === \"string\"\n        ) {\n          const value = n.value.extra ? n.value.extra.raw : n.value.raw;\n          res =\n            '\"' +\n            value.slice(1, value.length - 1).replace(/\"/g, \"&quot;\") +\n            '\"';\n        } else {\n          res = path.call(print, \"value\");\n        }\n        parts.push(\"=\", res);\n      }\n\n      return concat(parts);\n    case \"JSXIdentifier\":\n      return \"\" + n.name;\n    case \"JSXNamespacedName\":\n      return join(\":\", [\n        path.call(print, \"namespace\"),\n        path.call(print, \"name\")\n      ]);\n    case \"JSXMemberExpression\":\n      return join(\".\", [\n        path.call(print, \"object\"),\n        path.call(print, \"property\")\n      ]);\n    case \"JSXSpreadAttribute\":\n      return concat([\"{...\", path.call(print, \"argument\"), \"}\"]);\n    case \"JSXExpressionContainer\": {\n      const parent = path.getParentNode(0);\n\n      const shouldInline =\n        n.expression.type === \"ArrayExpression\" ||\n        n.expression.type === \"ObjectExpression\" ||\n        n.expression.type === \"ArrowFunctionExpression\" ||\n        n.expression.type === \"CallExpression\" ||\n        n.expression.type === \"FunctionExpression\" ||\n        n.expression.type === \"JSXEmptyExpression\" ||\n        n.expression.type === \"TemplateLiteral\" ||\n        n.expression.type === \"TaggedTemplateExpression\" ||\n        (parent.type === \"JSXElement\" &&\n          (n.expression.type === \"ConditionalExpression\" ||\n            isBinaryish(n.expression)));\n\n      if (shouldInline) {\n        return group(\n          concat([\"{\", path.call(print, \"expression\"), lineSuffixBoundary, \"}\"])\n        );\n      }\n\n      return group(\n        concat([\n          \"{\",\n          indent(concat([softline, path.call(print, \"expression\")])),\n          softline,\n          lineSuffixBoundary,\n          \"}\"\n        ])\n      );\n    }\n    case \"JSXElement\": {\n      const elem = printJSXElement(path, options, print);\n      return maybeWrapJSXElementInParens(path, elem, options);\n    }\n    case \"JSXOpeningElement\": {\n      const n = path.getValue();\n\n      // don't break up opening elements with a single long text attribute\n      if (\n        n.attributes.length === 1 &&\n        n.attributes[0].value &&\n        (n.attributes[0].value.type === \"Literal\" ||\n          n.attributes[0].value.type === \"StringLiteral\") &&\n        typeof n.attributes[0].value.value === \"string\"\n      ) {\n        return group(\n          concat([\n            \"<\",\n            path.call(print, \"name\"),\n            \" \",\n            concat(path.map(print, \"attributes\")),\n            n.selfClosing ? \" />\" : \">\"\n          ])\n        );\n      }\n\n      return group(\n        concat([\n          \"<\",\n          path.call(print, \"name\"),\n          concat([\n            indent(\n              concat(\n                path.map(attr => concat([line, print(attr)]), \"attributes\")\n              )\n            ),\n            n.selfClosing ? line : options.jsxBracketSameLine ? \">\" : softline\n          ]),\n          n.selfClosing ? \"/>\" : options.jsxBracketSameLine ? \"\" : \">\"\n        ])\n      );\n    }\n    case \"JSXClosingElement\":\n      return concat([\"</\", path.call(print, \"name\"), \">\"]);\n    case \"JSXText\":\n      throw new Error(\"JSXTest should be handled by JSXElement\");\n    case \"JSXEmptyExpression\":\n      const requiresHardline = n.comments && n.comments.some(\n        comment => comment.type === \"Line\" || comment.type === \"CommentLine\"\n      );\n\n      return concat([\n        comments.printDanglingComments(\n          path,\n          options,\n          /* sameIndent */ !requiresHardline\n        ),\n        requiresHardline ? hardline : \"\"\n      ]);\n    case \"TypeAnnotatedIdentifier\":\n      return concat([\n        path.call(print, \"annotation\"),\n        \" \",\n        path.call(print, \"identifier\")\n      ]);\n    case \"ClassBody\":\n      if (!n.comments && n.body.length === 0) {\n        return \"{}\";\n      }\n\n      return concat([\n        \"{\",\n        n.body.length > 0\n          ? indent(\n              concat([\n                hardline,\n                path.call(function(bodyPath) {\n                  return printStatementSequence(bodyPath, options, print);\n                }, \"body\")\n              ])\n            )\n          : comments.printDanglingComments(path, options),\n        hardline,\n        \"}\"\n      ]);\n    case \"ClassPropertyDefinition\":\n      parts.push(\"static \", path.call(print, \"definition\"));\n\n      if (!namedTypes.MethodDefinition.check(n.definition)) parts.push(semi);\n\n      return concat(parts);\n    case \"ClassProperty\":\n      if (n.static) parts.push(\"static \");\n\n      var key;\n\n      if (n.computed) {\n        key = concat([\"[\", path.call(print, \"key\"), \"]\"]);\n      } else {\n        key = printPropertyKey(path, options, print);\n\n        var variance = getFlowVariance(n, options);\n\n        if (variance) {\n          key = concat([variance, key]);\n        } else if (n.accessibility === \"public\") {\n          key = concat([\"public \", key]);\n        } else if (n.accessibility === \"protected\") {\n          key = concat([\"protected \", key]);\n        } else if (n.accessibility === \"private\") {\n          key = concat([\"private \", key]);\n        }\n      }\n\n      parts.push(key);\n\n      if (n.typeAnnotation) parts.push(path.call(print, \"typeAnnotation\"));\n\n      if (n.value) parts.push(\" = \", path.call(print, \"value\"));\n\n      parts.push(semi);\n\n      return concat(parts);\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      return concat(printClass(path, options, print));\n    case \"TemplateElement\":\n      return join(literalline, n.value.raw.split(\"\\n\"));\n    case \"TemplateLiteral\":\n      var expressions = path.map(print, \"expressions\");\n\n      parts.push(\"`\");\n\n      path.each(function(childPath) {\n        var i = childPath.getName();\n\n        parts.push(print(childPath));\n\n        if (i < expressions.length) {\n          parts.push(\n            \"${\",\n            removeLines(expressions[i]),\n            lineSuffixBoundary,\n            \"}\"\n          );\n        }\n      }, \"quasis\");\n\n      parts.push(\"`\");\n\n      return concat(parts);\n    // These types are unprintable because they serve as abstract\n    // supertypes for other (printable) types.\n    case \"TaggedTemplateExpression\":\n      return concat([path.call(print, \"tag\"), path.call(print, \"quasi\")]);\n    case \"Node\":\n    case \"Printable\":\n    case \"SourceLocation\":\n    case \"Position\":\n    case \"Statement\":\n    case \"Function\":\n    case \"Pattern\":\n    case \"Expression\":\n    case \"Declaration\":\n    case \"Specifier\":\n    case \"NamedSpecifier\":\n    // Supertype of Block and Line.\n    case \"Comment\":\n    // Flow\n    case \"MemberTypeAnnotation\": // Flow\n    case \"Type\":\n      throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n    // Type Annotations for Facebook Flow, typically stripped out or\n    // transformed away before printing.\n    case \"TypeAnnotation\":\n      if (n.typeAnnotation) {\n        if (\n          n.typeAnnotation.type !== \"FunctionTypeAnnotation\" &&\n          !shouldTypeScriptTypeAvoidColon(path) &&\n          // TypeScript should not have a colon before type parameter constraints\n          !(path.getParentNode().type === \"TypeParameter\" &&\n            path.getParentNode().constraint) &&\n          // TypeScript should not have a colon in TSFirstTypeNode nodes\n          // `a is number`\n          !(path.getParentNode().type === \"TypeAnnotation\" &&\n           path.getParentNode().typeAnnotation.type === 'TSFirstTypeNode')\n        ) {\n          parts.push(\": \");\n        }\n\n        parts.push(path.call(print, \"typeAnnotation\"));\n\n        return concat(parts);\n      }\n\n      return \"\";\n    case \"TSTupleType\":\n    case \"TupleTypeAnnotation\":\n      let typesField = n.type === \"TSTupleType\" ? \"elementTypes\" : \"types\";\n      return group(\n        concat([\n          \"[\",\n          indent(\n            concat([\n              softline,\n              printArrayItems(path, options, typesField, print)\n            ])\n          ),\n          ifBreak(shouldPrintComma(options) ? \",\" : \"\"),\n          comments.printDanglingComments(path, options, /* sameIndent */ true),\n          softline,\n          \"]\"\n        ])\n      );\n\n    case \"ExistsTypeAnnotation\":\n      return \"*\";\n    case \"EmptyTypeAnnotation\":\n      return \"empty\";\n    case \"AnyTypeAnnotation\":\n      return \"any\";\n    case \"MixedTypeAnnotation\":\n      return \"mixed\";\n    case \"ArrayTypeAnnotation\":\n      return concat([path.call(print, \"elementType\"), \"[]\"]);\n    case \"BooleanTypeAnnotation\":\n      return \"boolean\";\n    case \"BooleanLiteralTypeAnnotation\":\n      return \"\" + n.value;\n    case \"DeclareClass\":\n      return printFlowDeclaration(path, printClass(path, options, print));\n    case \"DeclareFunction\":\n      // For TypeScript the DeclareFunction node shares the AST\n      // structure with FunctionDeclaration\n      if (n.params) {\n        return concat([\n          \"declare \",\n          printFunctionDeclaration(path, print, options)\n        ]);\n      }\n      return printFlowDeclaration(path, [\n        \"function \",\n        path.call(print, \"id\"),\n        n.predicate ? \" \" : \"\",\n        path.call(print, \"predicate\"),\n        semi\n      ]);\n    case \"DeclareModule\":\n      return printFlowDeclaration(path, [\n        \"module \",\n        path.call(print, \"id\"),\n        \" \",\n        path.call(print, \"body\")\n      ]);\n    case \"DeclareModuleExports\":\n      return printFlowDeclaration(path, [\n        \"module.exports\",\n        path.call(print, \"typeAnnotation\"),\n        semi\n      ]);\n    case \"DeclareVariable\":\n      return printFlowDeclaration(path, [\"var \", path.call(print, \"id\"), semi]);\n    case \"DeclareExportAllDeclaration\":\n      return concat([\"declare export * from \", path.call(print, \"source\")]);\n    case \"DeclareExportDeclaration\":\n      return concat([\"declare \", printExportDeclaration(path, options, print)]);\n    case \"FunctionTypeAnnotation\":\n    case \"TSFunctionType\":\n      // FunctionTypeAnnotation is ambiguous:\n      // declare function foo(a: B): void; OR\n      // var A: (a: B) => void;\n      var parent = path.getParentNode(0);\n      var parentParent = path.getParentNode(1);\n      var isArrowFunctionTypeAnnotation =\n        n.type === \"TSFunctionType\" ||\n        !((!getFlowVariance(parent, options) &&\n          !parent.optional &&\n          namedTypes.ObjectTypeProperty.check(parent)) ||\n          namedTypes.ObjectTypeCallProperty.check(parent) ||\n          namedTypes.DeclareFunction.check(path.getParentNode(2)));\n\n      var needsColon =\n        isArrowFunctionTypeAnnotation &&\n        namedTypes.TypeAnnotation.check(parent);\n\n      // Sadly we can't put it inside of FastPath::needsColon because we are\n      // printing \":\" as part of the expression and it would put parenthesis\n      // around :(\n      const needsParens =\n        needsColon &&\n        isArrowFunctionTypeAnnotation &&\n        parent.type === \"TypeAnnotation\" &&\n        parentParent.type === \"ArrowFunctionExpression\";\n\n      if (isObjectTypePropertyAFunction(parent)) {\n        isArrowFunctionTypeAnnotation = true;\n        needsColon = true;\n      }\n\n      if (needsColon) {\n        parts.push(\": \");\n      }\n      if (needsParens) {\n        parts.push(\"(\");\n      }\n\n      parts.push(path.call(print, \"typeParameters\"));\n\n      parts.push(printFunctionParams(path, print, options));\n\n      // The returnType is not wrapped in a TypeAnnotation, so the colon\n      // needs to be added separately.\n      if (n.returnType || n.predicate || n.typeAnnotation) {\n        parts.push(\n          isArrowFunctionTypeAnnotation ? \" => \" : \": \",\n          path.call(print, \"returnType\"),\n          path.call(print, \"predicate\"),\n          path.call(print, \"typeAnnotation\")\n        );\n      }\n      if (needsParens) {\n        parts.push(\")\");\n      }\n\n      return group(concat(parts));\n    case \"FunctionTypeParam\":\n      return concat([\n        path.call(print, \"name\"),\n        n.optional ? \"?\" : \"\",\n        n.name ? \": \" : \"\",\n        path.call(print, \"typeAnnotation\")\n      ]);\n    case \"GenericTypeAnnotation\":\n      return concat([\n        path.call(print, \"id\"),\n        path.call(print, \"typeParameters\")\n      ]);\n    case \"DeclareInterface\":\n    case \"InterfaceDeclaration\": {\n      if (\n        n.type === \"DeclareInterface\" ||\n        isFlowNodeStartingWithDeclare(n, options)\n      ) {\n        parts.push(\"declare \");\n      }\n\n      parts.push(\n        \"interface \",\n        path.call(print, \"id\"),\n        path.call(print, \"typeParameters\")\n      );\n\n      if (n[\"extends\"].length > 0) {\n        parts.push(\n          group(\n            indent(\n              concat([line, \"extends \", join(\", \", path.map(print, \"extends\"))])\n            )\n          )\n        );\n      }\n\n      parts.push(\" \");\n      parts.push(path.call(print, \"body\"));\n\n      return group(concat(parts));\n    }\n    case \"ClassImplements\":\n    case \"InterfaceExtends\":\n      return concat([\n        path.call(print, \"id\"),\n        path.call(print, \"typeParameters\")\n      ]);\n    case \"IntersectionTypeAnnotation\": {\n      const types = path.map(print, \"types\");\n      const result = [];\n      for (let i = 0; i < types.length; ++i) {\n        if (i === 0) {\n          result.push(types[i]);\n        } else if (\n          n.types[i - 1].type !== \"ObjectTypeAnnotation\" &&\n          n.types[i].type !== \"ObjectTypeAnnotation\"\n        ) {\n          // If no object is involved, go to the next line if it breaks\n          result.push(indent(concat([\" &\", line, types[i]])));\n        } else {\n          // If you go from object to non-object or vis-versa, then inline it\n          result.push(\" & \", i > 1 ? indent(types[i]) : types[i]);\n        }\n      }\n      return group(concat(result));\n    }\n    case \"TSUnionType\":\n    case \"UnionTypeAnnotation\": {\n      // single-line variation\n      // A | B | C\n\n      // multi-line variation\n      // | A\n      // | B\n      // | C\n\n      const parent = path.getParentNode();\n      // If there's a leading comment, the parent is doing the indentation\n      const shouldIndent = !(parent.type === \"TypeAlias\" &&\n        hasLeadingOwnLineComment(options.originalText, n));\n\n      //const token = isIntersection ? \"&\" : \"|\";\n      const code = concat([\n        ifBreak(concat([shouldIndent ? line : \"\", \"| \"])),\n        join(concat([line, \"| \"]), path.map(print, \"types\"))\n      ]);\n\n      return group(shouldIndent ? indent(code) : code);\n    }\n    case \"NullableTypeAnnotation\":\n      return concat([\"?\", path.call(print, \"typeAnnotation\")]);\n    case \"NullLiteralTypeAnnotation\":\n      return \"null\";\n    case \"ThisTypeAnnotation\":\n      return \"this\";\n    case \"NumberTypeAnnotation\":\n      return \"number\";\n    case \"ObjectTypeCallProperty\":\n      if (n.static) {\n        parts.push(\"static \");\n      }\n\n      parts.push(path.call(print, \"value\"));\n\n      return concat(parts);\n    case \"ObjectTypeIndexer\":\n      var variance = getFlowVariance(n, options);\n      return concat([\n        variance || \"\",\n        \"[\",\n        path.call(print, \"id\"),\n        n.id ? \": \" : \"\",\n        path.call(print, \"key\"),\n        \"]: \",\n        path.call(print, \"value\")\n      ]);\n    case \"ObjectTypeProperty\":\n      var variance = getFlowVariance(n, options);\n      // TODO: This is a bad hack and we need a better way to know\n      // when to emit an arrow function or not.\n      var isFunction =\n        !variance && !n.optional && n.value.type === \"FunctionTypeAnnotation\";\n\n      if (isObjectTypePropertyAFunction(n)) {\n        isFunction = true;\n      }\n\n      return concat([\n        n.static ? \"static \" : \"\",\n        variance || \"\",\n        path.call(print, \"key\"),\n        n.optional ? \"?\" : \"\",\n        isFunction ? \"\" : \": \",\n        path.call(print, \"value\")\n      ]);\n    case \"QualifiedTypeIdentifier\":\n      return concat([\n        path.call(print, \"qualification\"),\n        \".\",\n        path.call(print, \"id\")\n      ]);\n    case \"StringLiteralTypeAnnotation\":\n      return nodeStr(n, options);\n    case \"NumberLiteralTypeAnnotation\":\n      assert.strictEqual(typeof n.value, \"number\");\n\n      if (n.extra != null) {\n        return printNumber(n.extra.raw);\n      } else {\n        return printNumber(n.raw);\n      }\n    case \"StringTypeAnnotation\":\n      return \"string\";\n    case \"DeclareTypeAlias\":\n    case \"TypeAlias\": {\n      if (\n        n.type === \"DeclareTypeAlias\" ||\n        isFlowNodeStartingWithDeclare(n, options)\n      ) {\n        parts.push(\"declare \");\n      }\n\n      parts.push(\n        \"type \",\n        path.call(print, \"id\"),\n        path.call(print, \"typeParameters\"),\n        \" =\",\n        hasLeadingOwnLineComment(options.originalText, n.right)\n          ? indent(concat([hardline, path.call(print, \"right\")]))\n          : concat([\" \", path.call(print, \"right\")]),\n        semi\n      );\n\n      return concat(parts);\n    }\n    case \"TypeCastExpression\":\n      return concat([\n        \"(\",\n        path.call(print, \"expression\"),\n        path.call(print, \"typeAnnotation\"),\n        \")\"\n      ]);\n    case \"TypeParameterDeclaration\":\n    case \"TypeParameterInstantiation\": {\n      const shouldInline =\n        n.params.length === 1 && n.params[0].type === \"ObjectTypeAnnotation\";\n\n      if (shouldInline) {\n        return concat([\"<\", join(\", \", path.map(print, \"params\")), \">\"]);\n      }\n\n      return group(\n        concat([\n          \"<\",\n          indent(\n            concat([\n              softline,\n              join(concat([\",\", line]), path.map(print, \"params\"))\n            ])\n          ),\n          softline,\n          \">\"\n        ])\n      );\n    }\n    case \"TypeParameter\":\n      var variance = getFlowVariance(n, options);\n\n      if (variance) {\n        parts.push(variance);\n      }\n\n      parts.push(path.call(print, \"name\"));\n\n      if (n.bound) {\n        parts.push(path.call(print, \"bound\"));\n      }\n\n      if (n.constraint) {\n        parts.push(\" extends \", path.call(print, \"constraint\"));\n      }\n\n      if (n[\"default\"]) {\n        parts.push(\"=\", path.call(print, \"default\"));\n      }\n\n      return concat(parts);\n    case \"TypeofTypeAnnotation\":\n      return concat([\"typeof \", path.call(print, \"argument\")]);\n    case \"VoidTypeAnnotation\":\n      return \"void\";\n    case \"NullTypeAnnotation\":\n      return \"null\";\n    case \"InferredPredicate\":\n      return \"%checks\";\n    // Unhandled types below. If encountered, nodes of these types should\n    // be either left alone or desugared into AST types that are fully\n    // supported by the pretty-printer.\n    case \"DeclaredPredicate\":\n      return concat([\"%checks(\", path.call(print, \"value\"), \")\"]);\n    case \"TSAnyKeyword\":\n      return \"any\";\n    case \"TSBooleanKeyword\":\n      return \"boolean\";\n    case \"TSNumberKeyword\":\n      return \"number\";\n    case \"TSObjectKeyword\":\n      return \"object\";\n    case \"TSStringKeyword\":\n      return \"string\";\n    case \"TSVoidKeyword\":\n      return \"void\";\n    case \"TSAsExpression\":\n      return concat([\n        path.call(print, \"expression\"),\n        \" as \",\n        path.call(print, \"typeAnnotation\")\n      ]);\n    case \"TSArrayType\":\n      return concat([path.call(print, \"elementType\"), \"[]\"]);\n    case \"TSPropertySignature\":\n      parts.push(path.call(print, \"name\"));\n      parts.push(path.call(print, \"typeAnnotation\"));\n\n      return concat(parts);\n    case \"TSTypeReference\":\n      return concat([path.call(print, \"typeName\")]);\n    case \"TSCallSignature\":\n      return concat([\n        \"(\",\n        join(\", \", path.map(print, \"parameters\")),\n        \"): \",\n        path.call(print, \"typeAnnotation\")\n      ]);\n    case \"TSConstructSignature\":\n      return concat([\n        \"new (\",\n        join(\", \", path.map(print, \"parameters\")),\n        \"): \",\n        path.call(print, \"typeAnnotation\")\n      ]);\n    case \"TSTypeQuery\":\n      return concat([\"typeof \", path.call(print, \"exprName\")]);\n    case \"TSParenthesizedType\":\n      return concat([\"(\", path.call(print, \"typeAnnotation\"), \")\"]);\n    case \"TSIndexSignature\":\n      return concat([\n        \"[\",\n        // This should only contain a single element, however TypeScript parses\n        // it using parseDelimitedList that uses commas as delimiter.\n        join(\", \", path.map(print, \"parameters\")),\n        \"]: \",\n        path.call(print, \"typeAnnotation\")\n      ]);\n    case \"TSFirstTypeNode\":\n      return concat([n.parameterName.name, \" is \", path.call(print, \"typeAnnotation\")])\n    // TODO\n    case \"ClassHeritage\":\n    // TODO\n    case \"ComprehensionBlock\":\n    // TODO\n    case \"ComprehensionExpression\":\n    // TODO\n    case \"Glob\":\n    // TODO\n    case \"GeneratorExpression\":\n    // TODO\n    case \"LetStatement\":\n    // TODO\n    case \"LetExpression\":\n    // TODO\n    case \"GraphExpression\":\n    // TODO\n    // XML types that nobody cares about or needs to print.\n    case \"GraphIndexExpression\":\n    case \"XMLDefaultDeclaration\":\n    case \"XMLAnyName\":\n    case \"XMLQualifiedIdentifier\":\n    case \"XMLFunctionQualifiedIdentifier\":\n    case \"XMLAttributeSelector\":\n    case \"XMLFilterExpression\":\n    case \"XML\":\n    case \"XMLElement\":\n    case \"XMLList\":\n    case \"XMLEscape\":\n    case \"XMLText\":\n    case \"XMLStartTag\":\n    case \"XMLEndTag\":\n    case \"XMLPointTag\":\n    case \"XMLName\":\n    case \"XMLAttribute\":\n    case \"XMLCdata\":\n    case \"XMLComment\":\n    case \"XMLProcessingInstruction\":\n    default:\n      debugger;\n      throw new Error(\"unknown type: \" + JSON.stringify(n.type));\n  }\n}\n\nfunction printStatementSequence(path, options, print) {\n  let printed = [];\n\n  const bodyNode = path.getNode();\n  const isClass = bodyNode.type === \"ClassBody\";\n\n  path.map((stmtPath, i) => {\n    var stmt = stmtPath.getValue();\n\n    // Just in case the AST has been modified to contain falsy\n    // \"statements,\" it's safer simply to skip them.\n    if (!stmt) {\n      return;\n    }\n\n    // Skip printing EmptyStatement nodes to avoid leaving stray\n    // semicolons lying around.\n    if (stmt.type === \"EmptyStatement\") {\n      return;\n    }\n\n    const stmtPrinted = print(stmtPath);\n    const text = options.originalText;\n    const parts = [];\n\n    // in no-semi mode, prepend statement with semicolon if it might break ASI\n    if (!options.semi && !isClass && stmtNeedsASIProtection(stmtPath)) {\n      if (\n        stmt.comments &&\n        stmt.comments.some(comment => comment.leading)\n      ) {\n        // Note: stmtNeedsASIProtection requires stmtPath to already be printed\n        // as it reads needsParens which is mutated on the instance\n        parts.push(print(stmtPath, { needsSemi: true }));\n      } else {\n        parts.push(\";\", stmtPrinted);\n      }\n    } else {\n      parts.push(stmtPrinted);\n    }\n\n\n    if (!options.semi && isClass) {\n      if (classPropMayCauseASIProblems(stmtPath)) {\n        parts.push(\";\");\n      } else if (stmt.type === \"ClassProperty\") {\n        const nextChild = bodyNode.body[i + 1];\n        if (classChildNeedsASIProtection(nextChild)) {\n          parts.push(\";\");\n        }\n      }\n    }\n\n    if (util.isNextLineEmpty(text, stmt) && !isLastStatement(stmtPath)) {\n      parts.push(hardline);\n    }\n\n    printed.push(concat(parts));\n  });\n\n  return join(hardline, printed);\n}\n\nfunction printPropertyKey(path, options, print) {\n  const node = path.getNode();\n  const key = node.key;\n\n  if (\n    (key.type === \"StringLiteral\" ||\n      (key.type === \"Literal\" && typeof key.value === \"string\")) &&\n    isIdentifierName(key.value) &&\n    !node.computed &&\n    // There's a bug in the flow parser where it throws if there are\n    // unquoted unicode literals as keys. Let's quote them for now.\n    (options.parser !== \"flow\" || key.value.match(/[a-zA-Z0-9$_]/))\n  ) {\n    // 'a' -> a\n    return path.call(\n      keyPath => comments.printComments(keyPath, p => key.value, options),\n      \"key\"\n    );\n  }\n  return path.call(print, \"key\");\n}\n\nfunction printMethod(path, options, print) {\n  var node = path.getNode();\n  var kind = node.kind;\n  var parts = [];\n\n  if (node.type === \"ObjectMethod\" || node.type === \"ClassMethod\") {\n    node.value = node;\n  } else {\n    namedTypes.FunctionExpression.assert(node.value);\n  }\n\n  if (node.value.async) {\n    parts.push(\"async \");\n  }\n\n  if (!kind || kind === \"init\" || kind === \"method\" || kind === \"constructor\") {\n    if (node.value.generator) {\n      parts.push(\"*\");\n    }\n  } else {\n    assert.ok(kind === \"get\" || kind === \"set\");\n\n    parts.push(kind, \" \");\n  }\n\n  var key = printPropertyKey(path, options, print);\n\n  if (node.computed) {\n    key = concat([\"[\", key, \"]\"]);\n  }\n\n  parts.push(\n    key,\n    path.call(print, \"value\", \"typeParameters\"),\n    group(\n      concat([\n        path.call(function(valuePath) {\n          return printFunctionParams(valuePath, print, options);\n        }, \"value\"),\n        path.call(p => printReturnType(p, print), \"value\")\n      ])\n    ),\n    \" \",\n    path.call(print, \"value\", \"body\")\n  );\n\n  return concat(parts);\n}\n\nfunction couldGroupArg(arg) {\n  return (\n    (arg.type === \"ObjectExpression\" && arg.properties.length > 0) ||\n    (arg.type === \"ArrayExpression\" && arg.elements.length > 0) ||\n    arg.type === \"FunctionExpression\" ||\n    (arg.type === \"ArrowFunctionExpression\" &&\n      (arg.body.type === \"BlockStatement\" ||\n        arg.body.type === \"ArrowFunctionExpression\" ||\n        arg.body.type === \"ObjectExpression\" ||\n        arg.body.type === \"ArrayExpression\" ||\n        arg.body.type === \"CallExpression\" ||\n        arg.body.type === \"JSXElement\"))\n  );\n}\n\nfunction shouldGroupLastArg(args) {\n  const lastArg = util.getLast(args);\n  const penultimateArg = util.getPenultimate(args);\n  return (\n    (!lastArg.comments || !lastArg.comments.length) &&\n    couldGroupArg(lastArg) &&\n    // If the last two arguments are of the same type,\n    // disable last element expansion.\n    (!penultimateArg || penultimateArg.type !== lastArg.type)\n  );\n}\n\nfunction shouldGroupFirstArg(args) {\n  if (args.length !== 2) {\n    return false;\n  }\n\n  const firstArg = args[0];\n  const secondArg = args[1];\n  return (\n    (!firstArg.comments || !firstArg.comments.length) &&\n    (firstArg.type === \"FunctionExpression\" ||\n      (firstArg.type === \"ArrowFunctionExpression\" &&\n        firstArg.body.type === \"BlockStatement\")) &&\n    !couldGroupArg(secondArg)\n  );\n}\n\nfunction printArgumentsList(path, options, print) {\n  var printed = path.map(print, \"arguments\");\n\n  if (printed.length === 0) {\n    return concat([\n      \"(\",\n      comments.printDanglingComments(path, options, /* sameIndent */ true),\n      \")\"\n    ]);\n  }\n\n  const args = path.getValue().arguments;\n  // This is just an optimization; I think we could return the\n  // conditional group for all function calls, but it's more expensive\n  // so only do it for specific forms.\n  const shouldGroupFirst = shouldGroupFirstArg(args);\n  const shouldGroupLast = shouldGroupLastArg(args);\n  if (shouldGroupFirst || shouldGroupLast) {\n    const shouldBreak = shouldGroupFirst\n      ? printed.slice(1).some(willBreak)\n      : printed.slice(0, -1).some(willBreak);\n\n    // We want to print the last argument with a special flag\n    let printedExpanded;\n    let i = 0;\n    path.each(function(argPath) {\n      if (shouldGroupFirst && i === 0) {\n        printedExpanded =\n          [argPath.call(p => print(p, { expandFirstArg: true }))]\n            .concat(printed.slice(1));\n      }\n      if (shouldGroupLast && i === args.length - 1) {\n        printedExpanded = printed\n          .slice(0, -1)\n          .concat(argPath.call(p => print(p, { expandLastArg: true })));\n      }\n      i++;\n    }, \"arguments\");\n\n    return concat([\n      printed.some(willBreak) ? breakParent : \"\",\n      conditionalGroup(\n        [\n          concat([\"(\", join(concat([\", \"]), printedExpanded), \")\"]),\n          shouldGroupFirst\n            ? concat([\n                \"(\",\n                group(printedExpanded[0], { shouldBreak: true }),\n                printed.length > 1 ? \", \" : \"\",\n                join(concat([\",\", line]), printed.slice(1)),\n                \")\"\n              ])\n            : concat([\n                \"(\",\n                join(concat([\",\", line]), printed.slice(0, -1)),\n                printed.length > 1 ? \", \" : \"\",\n                group(util.getLast(printedExpanded), {\n                  shouldBreak: true\n                }),\n                \")\"\n              ]),\n          group(\n            concat([\n              \"(\",\n              indent(concat([line, join(concat([\",\", line]), printed)])),\n              shouldPrintComma(options, \"all\") ? \",\" : \"\",\n              line,\n              \")\"\n            ]),\n            { shouldBreak: true }\n          )\n        ],\n        { shouldBreak }\n      )\n    ]);\n  }\n\n  return group(\n    concat([\n      \"(\",\n      indent(concat([softline, join(concat([\",\", line]), printed)])),\n      ifBreak(shouldPrintComma(options, \"all\") ? \",\" : \"\"),\n      softline,\n      \")\"\n    ]),\n    { shouldBreak: printed.some(willBreak) }\n  );\n}\n\nfunction printFunctionParams(path, print, options, expandArg) {\n  var fun = path.getValue();\n  // namedTypes.Function.assert(fun);\n  var paramsField = fun.type === \"TSFunctionType\" ? \"parameters\" : \"params\";\n  var printed = path.map(print, paramsField);\n\n  if (fun.defaults) {\n    path.each(function(defExprPath) {\n      var i = defExprPath.getName();\n      var p = printed[i];\n\n      if (p && defExprPath.getValue()) {\n        printed[i] = concat([p, \" = \", print(defExprPath)]);\n      }\n    }, \"defaults\");\n  }\n\n  if (fun.rest) {\n    printed.push(concat([\"...\", path.call(print, \"rest\")]));\n  }\n\n  if (printed.length === 0) {\n    return concat([\n      \"(\",\n      comments.printDanglingComments(path, options, /* sameIndent */ true),\n      \")\"\n    ]);\n  }\n\n  const lastParam = util.getLast(fun[paramsField]);\n  const canHaveTrailingComma =\n    !(lastParam && lastParam.type === \"RestElement\") && !fun.rest;\n\n  // If the parent is a call with the first/last argument expansion and this is the\n  // params of the first/last argument, we dont want the arguments to break and instead\n  // want the whole expression to be on a new line.\n  //\n  // Good:                 Bad:\n  //   verylongcall(         verylongcall((\n  //     (a, b) => {           a,\n  //     }                     b,\n  //   })                    ) => {\n  //                         })\n  if (expandArg) {\n    return group(concat([\"(\", join(\", \", printed.map(removeLines)), \")\"]));\n  }\n\n  // Single object destructuring should hug\n  //\n  // function({\n  //   a,\n  //   b,\n  //   c\n  // }) {}\n  if (\n    fun.params &&\n    fun.params.length === 1 &&\n    !fun.params[0].comments &&\n    (fun.params[0].type === \"ObjectPattern\" ||\n      (fun.params[0].type === \"FunctionTypeParam\" &&\n        fun.params[0].typeAnnotation.type === \"ObjectTypeAnnotation\")) &&\n    !fun.rest\n  ) {\n    return concat([\"(\", join(\", \", printed), \")\"]);\n  }\n\n  const parent = path.getParentNode();\n\n  const flowTypeAnnotations = [\n    \"AnyTypeAnnotation\",\n    \"NullLiteralTypeAnnotation\",\n    \"NullableTypeAnnotation\",\n    \"GenericTypeAnnotation\",\n    \"ThisTypeAnnotation\",\n    \"NumberTypeAnnotation\",\n    \"VoidTypeAnnotation\",\n    \"NullTypeAnnotation\",\n    \"EmptyTypeAnnotation\",\n    \"MixedTypeAnnotation\",\n    \"BooleanTypeAnnotation\",\n    \"BooleanLiteralTypeAnnotation\",\n    \"StringLiteralTypeAnnotation\",\n    \"StringTypeAnnotation\"\n  ];\n\n  const isFlowShorthandWithOneArg =\n    (isObjectTypePropertyAFunction(parent) ||\n      isTypeAnnotationAFunction(parent) ||\n      parent.type === \"TypeAlias\") &&\n    fun[paramsField].length === 1 &&\n    fun[paramsField][0].name === null &&\n    fun[paramsField][0].typeAnnotation &&\n    flowTypeAnnotations.indexOf(fun[paramsField][0].typeAnnotation.type) !== -1 &&\n    !fun.rest;\n\n  return concat([\n    isFlowShorthandWithOneArg ? \"\" : \"(\",\n    indent(concat([softline, join(concat([\",\", line]), printed)])),\n    ifBreak(\n      canHaveTrailingComma && shouldPrintComma(options, \"all\") ? \",\" : \"\"\n    ),\n    softline,\n    isFlowShorthandWithOneArg ? \"\" : \")\"\n  ]);\n}\n\nfunction canPrintParamsWithoutParens(node) {\n  return (\n    node.params.length === 1 &&\n    !node.rest &&\n    node.params[0].type === \"Identifier\" &&\n    !node.params[0].typeAnnotation &&\n    !node.params[0].comments &&\n    !node.params[0].optional &&\n    !node.predicate &&\n    !node.returnType\n  );\n}\n\nfunction printFunctionDeclaration(path, print, options) {\n  var n = path.getValue();\n  var parts = [];\n\n  if (n.async) parts.push(\"async \");\n\n  parts.push(\"function\");\n\n  if (n.generator) parts.push(\"*\");\n\n  if (n.id) {\n    parts.push(\" \", path.call(print, \"id\"));\n  }\n\n  parts.push(\n    path.call(print, \"typeParameters\"),\n    group(\n      concat([\n        printFunctionParams(path, print, options),\n        printReturnType(path, print)\n      ])\n    ),\n    \" \",\n    path.call(print, \"body\")\n  );\n\n  return concat(parts);\n}\n\nfunction printObjectMethod(path, options, print) {\n  var objMethod = path.getValue();\n  var parts = [];\n\n  if (objMethod.async) parts.push(\"async \");\n\n  if (objMethod.generator) parts.push(\"*\");\n\n  if (\n    objMethod.method || objMethod.kind === \"get\" || objMethod.kind === \"set\"\n  ) {\n    return printMethod(path, options, print);\n  }\n\n  var key = printPropertyKey(path, options, print);\n\n  if (objMethod.computed) {\n    parts.push(\"[\", key, \"]\");\n  } else {\n    parts.push(key);\n  }\n\n  if (objMethod.typeParameters) {\n    parts.push(path.call(print, \"typeParameters\"));\n  }\n\n  parts.push(\n    group(\n      concat([\n        printFunctionParams(path, print, options),\n        printReturnType(path, print)\n      ])\n    ),\n    \" \",\n    path.call(print, \"body\")\n  );\n\n  return concat(parts);\n}\n\nfunction printReturnType(path, print) {\n  const n = path.getValue();\n  const parts = [path.call(print, \"returnType\")];\n\n  if (n.predicate) {\n    // The return type will already add the colon, but otherwise we\n    // need to do it ourselves\n    parts.push(n.returnType ? \" \" : \": \", path.call(print, \"predicate\"));\n  }\n\n  return concat(parts);\n}\n\nfunction typeIsFunction(type) {\n  return (\n    type === \"FunctionExpression\" ||\n    type === \"ArrowFunctionExpression\" ||\n    type === \"NewExpression\"\n  );\n}\n\nfunction printExportDeclaration(path, options, print) {\n  const decl = path.getValue();\n  const semi = options.semi ? \";\" : \"\";\n  let parts = [\"export \"];\n\n  namedTypes.Declaration.assert(decl);\n\n  if (decl[\"default\"] || decl.type === \"ExportDefaultDeclaration\") {\n    parts.push(\"default \");\n  }\n\n  parts.push(\n    comments.printDanglingComments(path, options, /* sameIndent */ true)\n  );\n\n  if (decl.declaration) {\n    parts.push(path.call(print, \"declaration\"));\n\n    if (\n      decl.type === \"ExportDefaultDeclaration\" &&\n      (decl.declaration.type !== \"ClassDeclaration\" &&\n        decl.declaration.type !== \"FunctionDeclaration\")\n    ) {\n      parts.push(semi);\n    }\n  } else {\n    if (decl.specifiers && decl.specifiers.length > 0) {\n      if (\n        decl.specifiers.length === 1 &&\n        decl.specifiers[0].type === \"ExportBatchSpecifier\"\n      ) {\n        parts.push(\"*\");\n      } else {\n        let specifiers = [];\n        let defaultSpecifiers = [];\n        let namespaceSpecifiers = [];\n\n        path.map(specifierPath => {\n          const specifierType = path.getValue().type;\n          if (specifierType === \"ExportSpecifier\") {\n            specifiers.push(print(specifierPath));\n          } else if (specifierType === \"ExportDefaultSpecifier\") {\n            defaultSpecifiers.push(print(specifierPath));\n          } else if (specifierType === \"ExportNamespaceSpecifier\") {\n            namespaceSpecifiers.push(concat([\"* as \", print(specifierPath)]));\n          }\n        }, \"specifiers\");\n\n        const isNamespaceFollowed =\n          namespaceSpecifiers.length !== 0 &&\n          (specifiers.length !== 0 || defaultSpecifiers.length !== 0);\n        const isDefaultFollowed =\n          defaultSpecifiers.length !== 0 && specifiers.length !== 0;\n\n        parts.push(\n          decl.exportKind === \"type\" ? \"type \" : \"\",\n          concat(namespaceSpecifiers),\n          concat([isNamespaceFollowed ? \", \" : \"\"]),\n          concat(defaultSpecifiers),\n          concat([isDefaultFollowed ? \", \" : \"\"]),\n          specifiers.length !== 0\n            ? group(\n                concat([\n                  \"{\",\n                  indent(\n                    concat([\n                      options.bracketSpacing ? line : softline,\n                      join(concat([\",\", line]), specifiers)\n                    ])\n                  ),\n                  ifBreak(shouldPrintComma(options) ? \",\" : \"\"),\n                  options.bracketSpacing ? line : softline,\n                  \"}\"\n                ])\n              )\n            : \"\"\n        );\n      }\n    } else {\n      parts.push(\"{}\");\n    }\n\n    if (decl.source) {\n      parts.push(\" from \", path.call(print, \"source\"));\n    }\n\n    parts.push(semi);\n  }\n\n  return concat(parts);\n}\n\nfunction printFlowDeclaration(path, parts) {\n  var parentExportDecl = util.getParentExportDeclaration(path);\n\n  if (parentExportDecl) {\n    assert.strictEqual(parentExportDecl.type, \"DeclareExportDeclaration\");\n  } else {\n    // If the parent node has type DeclareExportDeclaration, then it\n    // will be responsible for printing the \"declare\" token. Otherwise\n    // it needs to be printed with this non-exported declaration node.\n    parts.unshift(\"declare \");\n  }\n\n  return concat(parts);\n}\n\nfunction getFlowVariance(path, options) {\n  if (!path.variance) {\n    return null;\n  }\n\n  // Babylon 7.0 currently uses variance node type, and flow should\n  // follow suit soon:\n  // https://github.com/babel/babel/issues/4722\n  const variance = path.variance.kind || path.variance;\n\n  switch (variance) {\n    case \"plus\":\n      return \"+\";\n\n    case \"minus\":\n      return \"-\";\n\n    default:\n      return variance;\n  }\n}\n\nfunction printClass(path, options, print) {\n  const n = path.getValue();\n  const parts = [\"class\"];\n\n  if (n.id) {\n    parts.push(\" \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n  }\n\n  const partsGroup = [];\n  if (n.superClass) {\n    partsGroup.push(\n      line,\n      \"extends \",\n      path.call(print, \"superClass\"),\n      path.call(print, \"superTypeParameters\")\n    );\n  } else if (n.extends && n.extends.length > 0) {\n    partsGroup.push(line, \"extends \", join(\", \", path.map(print, \"extends\")));\n  }\n\n  if (n[\"implements\"] && n[\"implements\"].length > 0) {\n    partsGroup.push(\n      line,\n      \"implements \",\n      join(\", \", path.map(print, \"implements\"))\n    );\n  }\n\n  if (partsGroup.length > 0) {\n    parts.push(group(indent(concat(partsGroup))));\n  }\n\n  parts.push(\" \", path.call(print, \"body\"));\n\n  return parts;\n}\n\nfunction printMemberLookup(path, options, print) {\n  const property = path.call(print, \"property\");\n  const n = path.getValue();\n\n  return concat(\n    n.computed\n      ? [\n          \"[\",\n          group(concat([indent(concat([softline, property])), softline])),\n          \"]\"\n        ]\n      : [\".\", property]\n  );\n}\n\n// We detect calls on member expressions specially to format a\n// comman pattern better. The pattern we are looking for is this:\n//\n// arr\n//   .map(x => x + 1)\n//   .filter(x => x > 10)\n//   .some(x => x % 2)\n//\n// The way it is structured in the AST is via a nested sequence of\n// MemberExpression and CallExpression. We need to traverse the AST\n// and make groups out of it to print it in the desired way.\nfunction printMemberChain(path, options, print) {\n  // The first phase is to linearize the AST by traversing it down.\n  //\n  //   a().b()\n  // has the following AST structure:\n  //   CallExpression(MemberExpression(CallExpression(Identifier)))\n  // and we transform it into\n  //   [Identifier, CallExpression, MemberExpression, CallExpression]\n  const printedNodes = [];\n\n  function rec(path) {\n    const node = path.getValue();\n    if (node.type === \"CallExpression\") {\n      printedNodes.unshift({\n        node: node,\n        printed: comments.printComments(\n          path,\n          p => printArgumentsList(path, options, print),\n          options\n        )\n      });\n      path.call(callee => rec(callee), \"callee\");\n    } else if (node.type === \"MemberExpression\") {\n      printedNodes.unshift({\n        node: node,\n        printed: comments.printComments(\n          path,\n          p => printMemberLookup(path, options, print),\n          options\n        )\n      });\n      path.call(object => rec(object), \"object\");\n    } else {\n      printedNodes.unshift({\n        node: node,\n        printed: path.call(print)\n      });\n    }\n  }\n  // Note: the comments of the root node have already been printed, so we\n  // need to extract this first call without printing them as they would\n  // if handled inside of the recursive call.\n  printedNodes.unshift({\n    node: path.getValue(),\n    printed: printArgumentsList(path, options, print)\n  });\n  path.call(callee => rec(callee), \"callee\");\n\n  // Once we have a linear list of printed nodes, we want to create groups out\n  // of it.\n  //\n  //   a().b.c().d().e\n  // will be grouped as\n  //   [\n  //     [Identifier, CallExpression],\n  //     [MemberExpression, MemberExpression, CallExpression],\n  //     [MemberExpression, CallExpression],\n  //     [MemberExpression],\n  //   ]\n  // so that we can print it as\n  //   a()\n  //     .b.c()\n  //     .d()\n  //     .e\n\n  // The first group is the first node followed by\n  //   - as many CallExpression as possible\n  //       < fn()()() >.something()\n  //   - then, as many MemberExpression as possible but the last one\n  //       < this.items >.something()\n  var groups = [];\n  var currentGroup = [printedNodes[0]];\n  var i = 1;\n  for (; i < printedNodes.length; ++i) {\n    if (printedNodes[i].node.type === \"CallExpression\") {\n      currentGroup.push(printedNodes[i]);\n    } else {\n      break;\n    }\n  }\n  for (; i + 1 < printedNodes.length; ++i) {\n    if (\n      printedNodes[i].node.type === \"MemberExpression\" &&\n      printedNodes[i + 1].node.type === \"MemberExpression\"\n    ) {\n      currentGroup.push(printedNodes[i]);\n    } else {\n      break;\n    }\n  }\n  groups.push(currentGroup);\n  currentGroup = [];\n\n  // Then, each following group is a sequence of MemberExpression followed by\n  // a sequence of CallExpression. To compute it, we keep adding things to the\n  // group until we has seen a CallExpression in the past and reach a\n  // MemberExpression\n  var hasSeenCallExpression = false;\n  for (; i < printedNodes.length; ++i) {\n    if (\n      hasSeenCallExpression && printedNodes[i].node.type === \"MemberExpression\"\n    ) {\n      // [0] should be appended at the end of the group instead of the\n      // beginning of the next one\n      if (printedNodes[i].node.computed) {\n        currentGroup.push(printedNodes[i]);\n        continue;\n      }\n\n      groups.push(currentGroup);\n      currentGroup = [];\n      hasSeenCallExpression = false;\n    }\n\n    if (printedNodes[i].node.type === \"CallExpression\") {\n      hasSeenCallExpression = true;\n    }\n    currentGroup.push(printedNodes[i]);\n  }\n  if (currentGroup.length > 0) {\n    groups.push(currentGroup);\n  }\n\n  // There are cases like Object.keys(), Observable.of(), _.values() where\n  // they are the subject of all the chained calls and therefore should\n  // be kept on the same line:\n  //\n  //   Object.keys(items)\n  //     .filter(x => x)\n  //     .map(x => x)\n  //\n  // In order to detect those cases, we use an heuristic: if the first\n  // node is just an identifier with the name starting with a capital\n  // letter, just a sequence of _$ or this. The rationale is that they are\n  // likely to be factories.\n  const shouldMerge =\n    groups.length >= 2 &&\n    !groups[1][0].node.comments &&\n    groups[0].length === 1 &&\n    (groups[0][0].node.type === \"ThisExpression\" ||\n      (groups[0][0].node.type === \"Identifier\" &&\n        groups[0][0].node.name.match(/(^[A-Z])|^[_$]+$/)));\n\n  function printGroup(printedGroup) {\n    return concat(printedGroup.map(tuple => tuple.printed));\n  }\n\n  function printIndentedGroup(groups) {\n    return indent(\n      group(concat([hardline, join(hardline, groups.map(printGroup))]))\n    );\n  }\n\n  const printedGroups = groups.map(printGroup);\n  const oneLine = concat(printedGroups);\n  const hasComment =\n    (groups.length >= 2 && groups[1][0].node.comments) ||\n    (groups.length >= 3 && groups[2][0].node.comments);\n\n  // If we only have a single `.`, we shouldn't do anything fancy and just\n  // render everything concatenated together.\n  if (\n    groups.length <= (shouldMerge ? 3 : 2) &&\n    !hasComment &&\n    // (a || b).map() should be break before .map() instead of ||\n    groups[0][0].node.type !== \"LogicalExpression\"\n  ) {\n    return group(oneLine);\n  }\n\n  const expanded = concat([\n    printGroup(groups[0]),\n    shouldMerge ? concat(groups.slice(1, 2).map(printGroup)) : \"\",\n    printIndentedGroup(groups.slice(shouldMerge ? 2 : 1))\n  ]);\n\n  // If there's a comment, we don't want to print in one line.\n  if (hasComment) {\n    return group(expanded);\n  }\n\n  // If any group but the last one has a hard line, we want to force expand\n  // it. If the last group is a function it's okay to inline if it fits.\n  if (printedGroups.slice(0, -1).some(willBreak)) {\n    return group(expanded);\n  }\n\n  return concat([\n    // We only need to check `oneLine` because if `expanded` is chosen\n    // that means that the parent group has already been broken\n    // naturally\n    willBreak(oneLine) ? breakParent : \"\",\n    conditionalGroup([oneLine, expanded])\n  ]);\n}\n\nfunction isEmptyJSXElement(node) {\n  if (node.children.length === 0) return true;\n  if (node.children.length > 1) return false;\n\n  // if there is one child but it's just a newline, treat as empty\n  const value = node.children[0].value;\n  if (!/\\S/.test(value) && /\\n/.test(value)) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// JSX Children are strange, mostly for two reasons:\n// 1. JSX reads newlines into string values, instead of skipping them like JS\n// 2. up to one whitespace between elements within a line is significant,\n//    but not between lines.\n//\n// So for one thing, '\\n' needs to be parsed out of string literals\n// and turned into hardlines (with string boundaries otherwise using softline)\n//\n// For another, leading, trailing, and lone whitespace all need to\n// turn themselves into the rather ugly `{' '}` when breaking.\nfunction printJSXChildren(path, options, print, jsxWhitespace) {\n  const n = path.getValue();\n  const children = [];\n\n  // using `map` instead of `each` because it provides `i`\n  path.map(function(childPath, i) {\n    const child = childPath.getValue();\n    const isLiteral = namedTypes.Literal.check(child);\n\n    if (isLiteral && typeof child.value === \"string\") {\n      // There's a bug in the flow parser where it doesn't unescape the\n      // value field. To workaround this, we can use rawValue which is\n      // correctly escaped (since it parsed).\n      // We really want to use value and re-escape it ourself when possible\n      // though.\n      const partiallyEscapedValue = options.parser === \"flow\"\n        ? child.raw\n        : util.htmlEscapeInsideAngleBracket(child.value);\n      const value = partiallyEscapedValue.replace(/\\u00a0/g, \"&nbsp;\");\n\n      if (/\\S/.test(value)) {\n        // treat each line of text as its own entity\n        value.split(/(\\r?\\n\\s*)/).forEach(line => {\n          const newlines = line.match(/\\n/g);\n          if (newlines) {\n            children.push(hardline);\n\n            // allow one extra newline\n            if (newlines.length > 1) {\n              children.push(hardline);\n            }\n            return;\n          }\n\n          const beginSpace = /^\\s+/.test(line);\n          if (beginSpace) {\n            children.push(jsxWhitespace);\n            children.push(softline);\n          }\n\n          const stripped = line.replace(/^\\s+|\\s+$/g, \"\");\n          if (stripped) {\n            children.push(stripped);\n          }\n\n          const endSpace = /\\s+$/.test(line);\n          if (endSpace) {\n            children.push(softline);\n            children.push(jsxWhitespace);\n          }\n        });\n\n        if (!isLineNext(util.getLast(children))) {\n          children.push(softline);\n        }\n      } else if (/\\n/.test(value)) {\n        children.push(hardline);\n\n        // allow one extra newline\n        if (value.match(/\\n/g).length > 1) {\n          children.push(hardline);\n        }\n      } else if (/\\s/.test(value)) {\n        // whitespace-only without newlines,\n        // eg; a single space separating two elements\n        children.push(jsxWhitespace);\n        children.push(softline);\n      }\n    } else {\n      children.push(print(childPath));\n\n      // add a line unless it's followed by a JSX newline\n      let next = n.children[i + 1];\n      if (!(next && /^\\s*\\n/.test(next.value))) {\n        children.push(softline);\n      }\n    }\n  }, \"children\");\n\n  return children;\n}\n\n// JSX expands children from the inside-out, instead of the outside-in.\n// This is both to break children before attributes,\n// and to ensure that when children break, their parents do as well.\n//\n// Any element that is written without any newlines and fits on a single line\n// is left that way.\n// Not only that, any user-written-line containing multiple JSX siblings\n// should also be kept on one line if possible,\n// so each user-written-line is wrapped in its own group.\n//\n// Elements that contain newlines or don't fit on a single line (recursively)\n// are fully-split, using hardline and shouldBreak: true.\n//\n// To support that case properly, all leading and trailing spaces\n// are stripped from the list of children, and replaced with a single hardline.\nfunction printJSXElement(path, options, print) {\n  const n = path.getValue();\n\n  // Turn <div></div> into <div />\n  if (isEmptyJSXElement(n)) {\n    n.openingElement.selfClosing = true;\n    delete n.closingElement;\n  }\n\n  const openingLines = path.call(print, \"openingElement\");\n  const closingLines = path.call(print, \"closingElement\");\n\n  if (\n    n.children.length === 1 &&\n    n.children[0].type === \"JSXExpressionContainer\" &&\n    (n.children[0].expression.type === \"TemplateLiteral\" ||\n      n.children[0].expression.type === \"TaggedTemplateExpression\")\n  ) {\n    return concat([\n      openingLines,\n      concat(path.map(print, \"children\")),\n      closingLines\n    ]);\n  }\n\n  // If no children, just print the opening element\n  if (n.openingElement.selfClosing) {\n    assert.ok(!n.closingElement);\n    return openingLines;\n  }\n  // Record any breaks. Should never go from true to false, only false to true.\n  let forcedBreak = willBreak(openingLines);\n\n  const jsxWhitespace = options.singleQuote\n    ? ifBreak(\"{' '}\", \" \")\n    : ifBreak('{\" \"}', \" \");\n  const children = printJSXChildren(path, options, print, jsxWhitespace);\n\n  // Trim trailing lines, recording if there was a hardline\n  let numTrailingHard = 0;\n  while (children.length && isLineNext(util.getLast(children))) {\n    if (willBreak(util.getLast(children))) {\n      ++numTrailingHard;\n      forcedBreak = true;\n    }\n    children.pop();\n  }\n  // allow one extra newline\n  if (numTrailingHard > 1) {\n    children.push(hardline);\n  }\n\n  // Trim leading lines, recording if there was a hardline\n  let numLeadingHard = 0;\n  while (children.length && isLineNext(children[0])) {\n    if (willBreak(children[0])) {\n      ++numLeadingHard;\n      forcedBreak = true;\n    }\n    children.shift();\n  }\n  // allow one extra newline\n  if (numLeadingHard > 1) {\n    children.unshift(hardline);\n  }\n\n  // Group by line, recording if there was a hardline.\n  let groups = [[]]; // Initialize the first line's group\n  children.forEach((child, i) => {\n    // leading and trailing JSX whitespace don't go into a group\n    if (child === jsxWhitespace) {\n      if (i === 0) {\n        groups.unshift(child);\n        return;\n      } else if (i === children.length - 1) {\n        groups.push(child);\n        return;\n      }\n    }\n\n    let prev = children[i - 1];\n    if (prev && willBreak(prev)) {\n      forcedBreak = true;\n\n      // On a new line, so create a new group and put this element in it.\n      groups.push([child]);\n    } else {\n      // Not on a newline, so add this element to the current group.\n      util.getLast(groups).push(child);\n    }\n\n    // Ensure we record hardline of last element.\n    if (!forcedBreak && i === children.length - 1) {\n      if (willBreak(child)) forcedBreak = true;\n    }\n  });\n\n  const childrenGroupedByLine = [\n    hardline,\n    // Conditional groups suppress break propagation; we want to output\n    // hard lines without breaking up the entire jsx element.\n    // Note that leading and trailing JSX Whitespace don't go into a group.\n    concat(\n      groups.map(\n        contents =>\n          (Array.isArray(contents)\n            ? conditionalGroup([concat(contents)])\n            : contents)\n      )\n    )\n  ];\n\n  const multiLineElem = group(\n    concat([\n      openingLines,\n      indent(group(concat(childrenGroupedByLine), { shouldBreak: true })),\n      hardline,\n      closingLines\n    ])\n  );\n\n  if (forcedBreak) {\n    return multiLineElem;\n  }\n\n  return conditionalGroup([\n    group(concat([openingLines, concat(children), closingLines])),\n    multiLineElem\n  ]);\n}\n\nfunction maybeWrapJSXElementInParens(path, elem, options) {\n  const parent = path.getParentNode();\n  if (!parent) return elem;\n\n  const NO_WRAP_PARENTS = {\n    ArrayExpression: true,\n    JSXElement: true,\n    JSXExpressionContainer: true,\n    ExpressionStatement: true,\n    CallExpression: true,\n    ConditionalExpression: true,\n    LogicalExpression: true\n  };\n  if (NO_WRAP_PARENTS[parent.type]) {\n    return elem;\n  }\n\n  return group(\n    concat([\n      ifBreak(\"(\"),\n      indent(concat([softline, elem])),\n      softline,\n      ifBreak(\")\")\n    ])\n  );\n}\n\nfunction isBinaryish(node) {\n  return node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\";\n}\n\nfunction shouldInlineLogicalExpression(node) {\n  return (\n    node.type === \"LogicalExpression\" &&\n    (node.right.type === \"ObjectExpression\" ||\n      node.right.type === \"ArrayExpression\")\n  );\n}\n\n// For binary expressions to be consistent, we need to group\n// subsequent operators with the same precedence level under a single\n// group. Otherwise they will be nested such that some of them break\n// onto new lines but not all. Operators with the same precedence\n// level should either all break or not. Because we group them by\n// precedence level and the AST is structured based on precedence\n// level, things are naturally broken up correctly, i.e. `&&` is\n// broken before `+`.\nfunction printBinaryishExpressions(path, print, options, isNested, isInsideParenthesis) {\n  let parts = [];\n  let node = path.getValue();\n\n  // We treat BinaryExpression and LogicalExpression nodes the same.\n  if (isBinaryish(node)) {\n    // Put all operators with the same precedence level in the same\n    // group. The reason we only need to do this with the `left`\n    // expression is because given an expression like `1 + 2 - 3`, it\n    // is always parsed like `((1 + 2) - 3)`, meaning the `left` side\n    // is where the rest of the expression will exist. Binary\n    // expressions on the right side mean they have a difference\n    // precedence level and should be treated as a separate group, so\n    // print them normally. (This doesn't hold for the `**` operator,\n    // which is unique in that it is right-associative.)\n    if (\n      util.getPrecedence(node.left.operator) ===\n        util.getPrecedence(node.operator) && node.operator !== \"**\"\n    ) {\n      // Flatten them out by recursively calling this function.\n      parts = parts.concat(\n        path.call(\n          left =>\n            printBinaryishExpressions(\n              left,\n              print,\n              options,\n              /* isNested */ true,\n              isInsideParenthesis\n            ),\n          \"left\"\n        )\n      );\n    } else {\n      parts.push(path.call(print, \"left\"));\n    }\n\n    const right = concat([\n      node.operator,\n      shouldInlineLogicalExpression(node) ? \" \" : line,\n      path.call(print, \"right\")\n    ]);\n\n    // If there's only a single binary expression, we want to create a group\n    // in order to avoid having a small right part like -1 be on its own line.\n    const parent = path.getParentNode();\n    const shouldGroup =\n      !(isInsideParenthesis && node.type === \"LogicalExpression\") &&\n      parent.type !== node.type &&\n      node.left.type !== node.type &&\n      node.right.type !== node.type;\n\n    parts.push(\" \", shouldGroup ? group(right) : right);\n\n    // The root comments are already printed, but we need to manually print\n    // the other ones since we don't call the normal print on BinaryExpression,\n    // only for the left and right parts\n    if (isNested && node.comments) {\n      parts = comments.printComments(path, p => concat(parts), options);\n    }\n  } else {\n    // Our stopping case. Simply print the node normally.\n    parts.push(path.call(print));\n  }\n\n  return parts;\n}\n\nfunction printAssignment(\n  leftNode,\n  printedLeft,\n  operator,\n  rightNode,\n  printedRight,\n  options\n) {\n  if (!rightNode) {\n    return printedLeft;\n  }\n\n  let printed;\n  if (hasLeadingOwnLineComment(options.originalText, rightNode)) {\n    printed = indent(concat([hardline, printedRight]));\n  } else if (\n    (isBinaryish(rightNode) && !shouldInlineLogicalExpression(rightNode)) ||\n    (leftNode.type === \"Identifier\" || leftNode.type === \"MemberExpression\") &&\n      (rightNode.type === \"StringLiteral\" ||\n        (rightNode.type === \"Literal\" && typeof rightNode.value === \"string\") ||\n        isMemberExpressionChain(rightNode))\n  ) {\n    printed = indent(concat([line, printedRight]));\n  } else {\n    printed = concat([\" \", printedRight]);\n  }\n\n  return group(concat([printedLeft, \" \", operator, printed]));\n}\n\nfunction adjustClause(node, clause, forceSpace) {\n  if (node.type === \"EmptyStatement\") {\n    return \";\";\n  }\n\n  if (node.type === \"BlockStatement\" || forceSpace) {\n    return concat([\" \", clause]);\n  }\n\n  return indent(concat([line, clause]));\n}\n\nfunction shouldTypeScriptTypeAvoidColon(path) {\n  // As the special TS nodes isn't returned by the node helpers,\n  // we use the stack directly to get the parent node.\n  const parent = path.stack[path.stack.length - 3];\n\n  switch (parent.type) {\n    case \"TSFunctionType\":\n    case \"TSIndexSignature\":\n    case \"TSParenthesizedType\":\n    case \"TSCallSignature\":\n    case \"TSConstructSignature\":\n    case \"TSAsExpression\":\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction nodeStr(node, options) {\n  const str = node.value;\n  isString.assert(str);\n\n  // Workaround a bug in the Javascript version of the flow parser where\n  // astral unicode characters like \\uD801\\uDC28 are incorrectly parsed as\n  // a sequence of \\uFFFD.\n  if (options.parser === \"flow\" && str.indexOf(\"\\ufffd\") !== -1) {\n    return node.raw;\n  }\n\n  const raw = node.extra ? node.extra.raw : node.raw;\n  // `rawContent` is the string exactly like it appeared in the input source\n  // code, with its enclosing quote.\n  const rawContent = raw.slice(1, -1);\n\n  const double = { quote: '\"', regex: /\"/g };\n  const single = { quote: \"'\", regex: /'/g };\n\n  const preferred = options.singleQuote ? single : double;\n  const alternate = preferred === single ? double : single;\n\n  let shouldUseAlternateQuote = false;\n\n  // If `rawContent` contains at least one of the quote preferred for enclosing\n  // the string, we might want to enclose with the alternate quote instead, to\n  // minimize the number of escaped quotes.\n  if (rawContent.includes(preferred.quote)) {\n    const numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;\n    const numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;\n\n    shouldUseAlternateQuote = numPreferredQuotes > numAlternateQuotes;\n  }\n\n  const enclosingQuote = shouldUseAlternateQuote\n    ? alternate.quote\n    : preferred.quote;\n\n  // It might sound unnecessary to use `makeString` even if `node.raw` already\n  // is enclosed with `enclosingQuote`, but it isn't. `node.raw` could contain\n  // unnecessary escapes (such as in `\"\\'\"`). Always using `makeString` makes\n  // sure that we consistently output the minimum amount of escaped quotes.\n  return makeString(rawContent, enclosingQuote);\n}\n\nfunction makeString(rawContent, enclosingQuote) {\n  const otherQuote = enclosingQuote === '\"' ? \"'\" : '\"';\n\n  // Matches _any_ escape and unescaped quotes (both single and double).\n  const regex = /\\\\([\\s\\S])|(['\"])/g;\n\n  // Escape and unescape single and double quotes as needed to be able to\n  // enclose `rawContent` with `enclosingQuote`.\n  const newContent = rawContent.replace(regex, (match, escaped, quote) => {\n    // If we matched an escape, and the escaped character is a quote of the\n    // other type than we intend to enclose the string with, there's no need for\n    // it to be escaped, so return it _without_ the backslash.\n    if (escaped === otherQuote) {\n      return escaped;\n    }\n\n    // If we matched an unescaped quote and it is of the _same_ type as we\n    // intend to enclose the string with, it must be escaped, so return it with\n    // a backslash.\n    if (quote === enclosingQuote) {\n      return \"\\\\\" + quote;\n    }\n\n    // Otherwise return the escape or unescaped quote as-is.\n    return match;\n  });\n\n  return enclosingQuote + newContent + enclosingQuote;\n}\n\nfunction printRegex(node) {\n  const flags = node.flags.split('').sort().join('');\n  return `/${node.pattern}/${flags}`;\n}\n\nfunction printNumber(rawNumber) {\n  return (\n    rawNumber\n      .toLowerCase()\n      // Remove unnecessary plus and zeroes from scientific notation.\n      .replace(/^([\\d.]+e)(?:\\+|(-))?0*(\\d)/, \"$1$2$3\")\n      // Remove unnecessary scientific notation (1e0).\n      .replace(/^([\\d.]+)e[+-]?0+$/, \"$1\")\n      // Make sure numbers always start with a digit.\n      .replace(/^\\./, \"0.\")\n      // Remove trailing dot.\n      .replace(/\\.(?=e|$)/, \"\")\n  );\n}\n\nfunction isFirstStatement(path) {\n  const parent = path.getParentNode();\n  const node = path.getValue();\n  const body = parent.body;\n  return body && body[0] === node;\n}\n\nfunction isLastStatement(path) {\n  const parent = path.getParentNode();\n  const node = path.getValue();\n  const body = parent.body;\n  return body && body[body.length - 1] === node;\n}\n\nfunction hasLeadingOwnLineComment(text, node) {\n  const res =\n    node.comments &&\n    node.comments.some(\n      comment => comment.leading && util.hasNewline(text, util.locEnd(comment))\n    );\n  return res;\n}\n\nfunction hasNakedLeftSide(node) {\n  return (\n    node.type === \"AssignmentExpression\" ||\n    node.type === \"BinaryExpression\" ||\n    node.type === \"LogicalExpression\" ||\n    node.type === \"ConditionalExpression\" ||\n    node.type === \"CallExpression\" ||\n    node.type === \"MemberExpression\" ||\n    node.type === \"SequenceExpression\" ||\n    node.type === \"TaggedTemplateExpression\"\n  );\n}\n\nfunction getLeftSide(node) {\n  if (node.expressions) {\n    return node.expressions[0];\n  }\n  return node.left || node.test || node.callee || node.object || node.tag;\n}\n\nfunction exprNeedsASIProtection(node) {\n  // HACK: node.needsParens is added in `genericPrint()` for the sole purpose\n  // of being used here. It'd be preferable to find a cleaner way to do this.\n  const maybeASIProblem =\n    node.needsParens ||\n    node.type === \"ParenthesizedExpression\" ||\n    node.type === \"TypeCastExpression\" ||\n    (node.type === \"ArrowFunctionExpression\" &&\n      !canPrintParamsWithoutParens(node)) ||\n    node.type === \"ArrayExpression\" ||\n    node.type === \"ArrayPattern\" ||\n    (node.type === \"UnaryExpression\" &&\n      node.prefix &&\n      (node.operator === \"+\" || node.operator === \"-\")) ||\n    node.type === \"TemplateLiteral\" ||\n    node.type === \"TemplateElement\" ||\n    node.type === \"JSXElement\" ||\n    node.type === \"RegExpLiteral\" ||\n    (node.type === \"Literal\" && node.pattern) ||\n    (node.type === \"Literal\" && node.regex);\n\n  if (maybeASIProblem) {\n    return true;\n  }\n\n  if (!hasNakedLeftSide(node)) {\n    return false;\n  }\n\n  return exprNeedsASIProtection(getLeftSide(node));\n}\n\nfunction stmtNeedsASIProtection(path) {\n  if (!path) return false;\n  const node = path.getNode();\n\n  if (node.type !== \"ExpressionStatement\") {\n    return false;\n  }\n\n  return exprNeedsASIProtection(node.expression);\n}\n\nfunction classPropMayCauseASIProblems(path) {\n  const node = path.getNode();\n\n  if (node.type !== \"ClassProperty\") {\n    return false;\n  }\n\n  const name = node.key && node.key.name;\n  if (!name) {\n    return false;\n  }\n\n  // this isn't actually possible yet with most parsers available today\n  // so isn't properly tested yet.\n  if (name === \"static\" || name === \"get\" || name === \"set\") {\n    return true;\n  }\n}\n\nfunction classChildNeedsASIProtection(node) {\n  if (!node) return;\n\n  let isAsync, isGenerator;\n  switch (node.type) {\n    case \"ClassProperty\":\n      return node.computed;\n    // flow\n    case \"MethodDefinition\":\n    // babylon\n    case \"ClassMethod\": {\n      const isAsync = node.value ? node.value.async : node.async;\n      const isGenerator = node.value ? node.value.generator : node.generator;\n      if (\n        isAsync || node.static || node.kind === \"get\" || node.kind === \"set\"\n      ) {\n        return false;\n      }\n      if (node.computed || isGenerator) {\n        return true;\n      }\n    }\n\n    default:\n      return false;\n  }\n}\n\n// This recurses the return argument, looking for the first token\n// (the leftmost leaf node) and, if it (or its parents) has any\n// leadingComments, returns true (so it can be wrapped in parens).\nfunction returnArgumentHasLeadingComment(options, argument) {\n  if (hasLeadingOwnLineComment(options.originalText, argument)) {\n    return true;\n  }\n\n  if (hasNakedLeftSide(argument)) {\n    let leftMost = argument;\n    let newLeftMost;\n    while ((newLeftMost = getLeftSide(leftMost))) {\n      leftMost = newLeftMost;\n\n      if (hasLeadingOwnLineComment(options.originalText, leftMost)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isMemberExpressionChain(node) {\n  if (node.type !== \"MemberExpression\") {\n    return false;\n  }\n  if (node.object.type === \"Identifier\") {\n    return true;\n  }\n  return isMemberExpressionChain(node.object);\n}\n\n// Hack to differentiate between the following two which have the same ast\n// type T = { method: () => void };\n// type T = { method(): void };\nfunction isObjectTypePropertyAFunction(node) {\n  return (\n    node.type === \"ObjectTypeProperty\" &&\n    node.value.type === \"FunctionTypeAnnotation\" &&\n    !node.static &&\n    util.locStart(node.key) !== util.locStart(node.value)\n  );\n}\n\n// Hack to differentiate between the following two which have the same ast\n// declare function f(a): void;\n// var f: (a) => void;\nfunction isTypeAnnotationAFunction(node) {\n  return (\n    node.type === \"TypeAnnotation\" &&\n    node.typeAnnotation.type === \"FunctionTypeAnnotation\" &&\n    !node.static &&\n    util.locStart(node) !== util.locStart(node.typeAnnotation)\n  );\n}\n\nfunction isFlowNodeStartingWithDeclare(node, options) {\n  if (options.parser !== \"flow\") {\n    return false;\n  }\n\n  return options.originalText\n    .slice(0, util.locStart(node))\n    .match(/declare\\s*$/);\n}\n\nfunction printArrayItems(path, options, printPath, print) {\n  const printedElements = [];\n  let separatorParts = [];\n\n  path.each(function(childPath) {\n    printedElements.push(concat(separatorParts));\n    printedElements.push(group(print(childPath)));\n\n    separatorParts = [\",\", line];\n    if (\n      childPath.getValue() &&\n      util.isNextLineEmpty(options.originalText, childPath.getValue())\n    ) {\n      separatorParts.push(softline);\n    }\n  }, printPath);\n\n  return concat(printedElements);\n}\n\nfunction removeLines(doc) {\n  // Force this doc into flat mode by statically converting all\n  // lines into spaces (or soft lines into nothing). Hard lines\n  // should still output because there's too great of a chance\n  // of breaking existing assumptions otherwise.\n  return docUtils.mapDoc(doc, d => {\n    if (d.type === \"line\" && !d.hard) {\n      return d.soft ? \"\" : \" \";\n    } else if (d.type === \"if-break\") {\n      return d.flatContents || \"\";\n    }\n    return d;\n  });\n}\n\nfunction printAstToDoc(ast, options) {\n  function printGenerically(path, args) {\n    return comments.printComments(\n      path,\n      p => genericPrint(p, options, printGenerically, args),\n      options,\n      args && args.needsSemi\n    );\n  }\n\n  const doc = printGenerically(FastPath.from(ast));\n  docUtils.propagateBreaks(doc);\n  return doc;\n}\n\nmodule.exports = { printAstToDoc };\n","/home/travis/build/npmtest/node-npmtest-prettier/node_modules/prettier/src/fast-path.js":"\"use strict\";\n\nvar assert = require(\"assert\");\nvar types = require(\"ast-types\");\nvar util = require(\"./util\");\nvar n = types.namedTypes;\nvar Node = n.Node;\nvar isArray = types.builtInTypes.array;\nvar isNumber = types.builtInTypes.number;\n\nfunction FastPath(value) {\n  assert.ok(this instanceof FastPath);\n  this.stack = [value];\n}\n\nvar FPp = FastPath.prototype;\n\n// Static convenience function for coercing a value to a FastPath.\nFastPath.from = function(obj) {\n  if (obj instanceof FastPath) {\n    // Return a defensive copy of any existing FastPath instances.\n    return obj.copy();\n  }\n\n  if (obj instanceof types.NodePath) {\n    // For backwards compatibility, unroll NodePath instances into\n    // lightweight FastPath [..., name, value] stacks.\n    var copy = Object.create(FastPath.prototype);\n    var stack = [obj.value];\n    for (var pp; (pp = obj.parentPath); obj = pp)\n      stack.push(obj.name, pp.value);\n    copy.stack = stack.reverse();\n    return copy;\n  }\n\n  // Otherwise use obj as the value of the new FastPath instance.\n  return new FastPath(obj);\n};\n\nFPp.copy = function copy() {\n  var copy = Object.create(FastPath.prototype);\n  copy.stack = this.stack.slice(0);\n  return copy;\n};\n\n// The name of the current property is always the penultimate element of\n// this.stack, and always a String.\nFPp.getName = function getName() {\n  var s = this.stack;\n  var len = s.length;\n  if (len > 1) {\n    return s[len - 2];\n  }\n  // Since the name is always a string, null is a safe sentinel value to\n  // return if we do not know the name of the (root) value.\n  return null;\n};\n\n// The value of the current property is always the final element of\n// this.stack.\nFPp.getValue = function getValue() {\n  var s = this.stack;\n  return s[s.length - 1];\n};\n\nfunction getNodeHelper(path, count) {\n  var s = path.stack;\n\n  for (var i = s.length - 1; i >= 0; i -= 2) {\n    var value = s[i];\n    if (n.Node.check(value) && --count < 0) {\n      return value;\n    }\n  }\n\n  return null;\n}\n\nFPp.getNode = function getNode(count) {\n  return getNodeHelper(this, ~~count);\n};\n\nFPp.getParentNode = function getParentNode(count) {\n  return getNodeHelper(this, ~~count + 1);\n};\n\nFPp.isLast = function isLast() {\n  var s = this.stack;\n  if (this.getParentNode()) {\n    var idx = s[s.length - 2];\n    // The name of this node should be an index\n    assert.ok(typeof idx === \"number\");\n\n    const arr = s[s.length - 3];\n    // We should have an array as a parent node\n    assert.ok(Array.isArray(arr));\n\n    return idx === arr.length - 1;\n  }\n  return false;\n};\n\n// Temporarily push properties named by string arguments given after the\n// callback function onto this.stack, then call the callback with a\n// reference to this (modified) FastPath object. Note that the stack will\n// be restored to its original state after the callback is finished, so it\n// is probably a mistake to retain a reference to the path.\nFPp.call = function call(callback /*, name1, name2, ... */) {\n  var s = this.stack;\n  var origLen = s.length;\n  var value = s[origLen - 1];\n  var argc = arguments.length;\n  for (var i = 1; i < argc; ++i) {\n    var name = arguments[i];\n    value = value[name];\n    s.push(name, value);\n  }\n  var result = callback(this);\n  s.length = origLen;\n  return result;\n};\n\n// Similar to FastPath.prototype.call, except that the value obtained by\n// accessing this.getValue()[name1][name2]... should be array-like. The\n// callback will be called with a reference to this path object for each\n// element of the array.\nFPp.each = function each(callback /*, name1, name2, ... */) {\n  var s = this.stack;\n  var origLen = s.length;\n  var value = s[origLen - 1];\n  var argc = arguments.length;\n\n  for (var i = 1; i < argc; ++i) {\n    var name = arguments[i];\n    value = value[name];\n    s.push(name, value);\n  }\n\n  for (var i = 0; i < value.length; ++i) {\n    if (i in value) {\n      s.push(i, value[i]);\n      // If the callback needs to know the value of i, call\n      // path.getName(), assuming path is the parameter name.\n      callback(this);\n      s.length -= 2;\n    }\n  }\n\n  s.length = origLen;\n};\n\n// Similar to FastPath.prototype.each, except that the results of the\n// callback function invocations are stored in an array and returned at\n// the end of the iteration.\nFPp.map = function map(callback /*, name1, name2, ... */) {\n  var s = this.stack;\n  var origLen = s.length;\n  var value = s[origLen - 1];\n  var argc = arguments.length;\n\n  for (var i = 1; i < argc; ++i) {\n    var name = arguments[i];\n    value = value[name];\n    s.push(name, value);\n  }\n\n  var result = new Array(value.length);\n\n  for (var i = 0; i < value.length; ++i) {\n    if (i in value) {\n      s.push(i, value[i]);\n      result[i] = callback(this, i);\n      s.length -= 2;\n    }\n  }\n\n  s.length = origLen;\n\n  return result;\n};\n\n// Inspired by require(\"ast-types\").NodePath.prototype.needsParens, but\n// more efficient because we're iterating backwards through a stack.\nFPp.needsParens = function(assumeExpressionContext) {\n  var parent = this.getParentNode();\n  if (!parent) {\n    return false;\n  }\n\n  var name = this.getName();\n  var node = this.getNode();\n\n  // If the value of this path is some child of a Node and not a Node\n  // itself, then it doesn't need parentheses. Only Node objects (in\n  // fact, only Expression nodes) need parentheses.\n  if (this.getValue() !== node) {\n    return false;\n  }\n\n  // Only statements don't need parentheses.\n  if (n.Statement.check(node)) {\n    return false;\n  }\n\n  // Identifiers never need parentheses.\n  if (node.type === \"Identifier\") {\n    return false;\n  }\n\n  if (parent.type === \"ParenthesizedExpression\") {\n    return false;\n  }\n\n  // Add parens around the extends clause of a class. It is needed for almost\n  // all expressions.\n  if (\n    (parent.type === \"ClassDeclaration\" || parent.type === \"ClassExpression\") &&\n    parent.superClass === node &&\n    (node.type === \"ArrowFunctionExpression\" ||\n      node.type === \"AssignmentExpression\" ||\n      node.type === \"AwaitExpression\" ||\n      node.type === \"BinaryExpression\" ||\n      node.type === \"ConditionalExpression\" ||\n      node.type === \"LogicalExpression\" ||\n      node.type === \"NewExpression\" ||\n      node.type === \"ObjectExpression\" ||\n      node.type === \"ParenthesizedExpression\" ||\n      node.type === \"SequenceExpression\" ||\n      node.type === \"TaggedTemplateExpression\" ||\n      node.type === \"UnaryExpression\" ||\n      node.type === \"UpdateExpression\" ||\n      node.type === \"YieldExpression\")\n  ) {\n    return true;\n  }\n\n  if (\n    (parent.type === \"ArrowFunctionExpression\" &&\n      parent.body === node &&\n      startsWithNoLookaheadToken(node, /* forbidFunctionAndClass */ false)) ||\n    (parent.type === \"ExpressionStatement\" &&\n      startsWithNoLookaheadToken(node, /* forbidFunctionAndClass */ true))\n  ) {\n    return true;\n  }\n\n  switch (node.type) {\n    case \"CallExpression\":\n      if (parent.type === \"NewExpression\" && parent.callee === node) {\n        return true;\n      }\n      return false;\n\n    case \"SpreadElement\":\n    case \"SpreadProperty\":\n      return (\n        parent.type === \"MemberExpression\" &&\n        name === \"object\" &&\n        parent.object === node\n      );\n\n    case \"UpdateExpression\":\n      if (parent.type === \"UnaryExpression\") {\n        return (\n          node.prefix &&\n          ((node.operator === \"++\" && parent.operator === \"+\") ||\n            (node.operator === \"--\" && parent.operator === \"-\"))\n        );\n      }\n    // else fall through\n    case \"UnaryExpression\":\n      switch (parent.type) {\n        case \"UnaryExpression\":\n          return (\n            node.operator === parent.operator &&\n            (node.operator === \"+\" || node.operator === \"-\")\n          );\n\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        case \"TaggedTemplateExpression\":\n          return true;\n\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"BinaryExpression\":\n          return parent.operator === \"**\" && name === \"left\";\n\n        default:\n          return false;\n      }\n\n    case \"BinaryExpression\":\n      const isLeftOfAForStatement = node => {\n        let i = 0;\n        while (node) {\n          let parent = this.getParentNode(i++);\n          if (!parent) {\n            return false;\n          }\n          if (parent.type === \"ForStatement\" && parent.init === node) {\n            return true;\n          }\n          node = parent;\n        }\n        return false;\n      };\n      if (node.operator === \"in\" && isLeftOfAForStatement(node)) {\n        return true;\n      }\n    // else fall through\n    case \"LogicalExpression\":\n      switch (parent.type) {\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n          return true;\n\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n          var po = parent.operator;\n          var pp = util.getPrecedence(po);\n          var no = node.operator;\n          var np = util.getPrecedence(no);\n\n          if (po === \"||\" && no === \"&&\") {\n            return true;\n          }\n\n          if (pp > np) {\n            return true;\n          }\n\n          if (no === \"**\" && po === \"**\") {\n            return name === \"left\";\n          }\n\n          if (pp === np && name === \"right\") {\n            assert.strictEqual(parent.right, node);\n            return true;\n          }\n\n          // Add parenthesis when working with binary operators\n          // It's not stricly needed but helps with code understanding\n          if ([\"|\", \"^\", \"&\", \">>\", \"<<\", \">>>\"].indexOf(po) !== -1) {\n            return true;\n          }\n\n        default:\n          return false;\n      }\n\n    case \"SequenceExpression\":\n      switch (parent.type) {\n        case \"ReturnStatement\":\n          return false;\n\n        case \"ForStatement\":\n          // Although parentheses wouldn't hurt around sequence\n          // expressions in the head of for loops, traditional style\n          // dictates that e.g. i++, j++ should not be wrapped with\n          // parentheses.\n          return false;\n\n        case \"ExpressionStatement\":\n          return name !== \"expression\";\n\n        default:\n          // Otherwise err on the side of overparenthesization, adding\n          // explicit exceptions above if this proves overzealous.\n          return true;\n      }\n\n    case \"YieldExpression\":\n      if (parent.type === \"UnaryExpression\") {\n        return true;\n      }\n    // else fall through\n    case \"AwaitExpression\":\n      switch (parent.type) {\n        case \"TaggedTemplateExpression\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"NewExpression\":\n        case \"MemberExpression\":\n          return true;\n\n        case \"CallExpression\":\n          return parent.callee === node;\n\n        case \"ConditionalExpression\":\n          return parent.test === node;\n\n        default:\n          return false;\n      }\n\n    case \"ArrayTypeAnnotation\":\n      return parent.type === \"NullableTypeAnnotation\";\n\n    case \"IntersectionTypeAnnotation\":\n    case \"UnionTypeAnnotation\":\n      return (\n        parent.type === \"ArrayTypeAnnotation\" ||\n        parent.type === \"NullableTypeAnnotation\" ||\n        parent.type === \"IntersectionTypeAnnotation\" ||\n        parent.type === \"UnionTypeAnnotation\"\n      );\n\n    case \"NullableTypeAnnotation\":\n      return parent.type === \"ArrayTypeAnnotation\";\n\n    case \"FunctionTypeAnnotation\":\n      return (\n        parent.type === \"UnionTypeAnnotation\" ||\n        parent.type === \"IntersectionTypeAnnotation\"\n      );\n\n    case \"NumericLiteral\":\n    case \"Literal\":\n      return (\n        parent.type === \"MemberExpression\" &&\n        isNumber.check(node.value) &&\n        name === \"object\" &&\n        parent.object === node\n      );\n\n    case \"AssignmentExpression\":\n      if (parent.type === \"ArrowFunctionExpression\" && parent.body === node) {\n        return true;\n      } else if (\n        parent.type === \"ForStatement\" &&\n        (parent.init === node || parent.update === node)\n      ) {\n        return false;\n      } else if (parent.type === \"ExpressionStatement\") {\n        return node.left.type === \"ObjectPattern\";\n      } else if (parent.type === \"AssignmentExpression\") {\n        return false;\n      }\n      return true;\n\n    case \"ConditionalExpression\":\n      switch (parent.type) {\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n        case \"ExportDefaultDeclaration\":\n        case \"AwaitExpression\":\n        case \"JSXSpreadAttribute\":\n        case \"ArrowFunctionExpression\":\n          return true;\n\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"ConditionalExpression\":\n          return name === \"test\" && parent.test === node;\n\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        default:\n          return false;\n      }\n\n    case \"FunctionExpression\":\n      switch (parent.type) {\n        case \"CallExpression\":\n          return name === \"callee\"; // Not strictly necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.\n        case \"TaggedTemplateExpression\":\n          return true; // This is basically a kind of IIFE.\n        case \"ExportDefaultDeclaration\":\n          return true;\n        default:\n          return false;\n      }\n\n    case \"ArrowFunctionExpression\":\n      switch (parent.type) {\n        case \"CallExpression\":\n          return name === \"callee\";\n\n        case \"NewExpression\":\n          return name === \"callee\";\n\n        case \"MemberExpression\":\n          return name === \"object\";\n\n        case \"BindExpression\":\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"LogicalExpression\":\n        case \"BinaryExpression\":\n          return true;\n\n        case \"ConditionalExpression\":\n          return name === \"test\";\n\n        default:\n          return false;\n      }\n\n    case \"ClassExpression\":\n      return parent.type === \"ExportDefaultDeclaration\";\n\n    case \"StringLiteral\":\n      return parent.type === \"ExpressionStatement\"; // To avoid becoming a directive\n  }\n\n  if (\n    parent.type === \"NewExpression\" &&\n    name === \"callee\" &&\n    parent.callee === node\n  ) {\n    return containsCallExpression(node);\n  }\n\n  return false;\n};\n\nfunction isBinary(node) {\n  return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);\n}\n\nfunction containsCallExpression(node) {\n  if (n.CallExpression.check(node)) {\n    return true;\n  }\n\n  if (isArray.check(node)) {\n    return node.some(containsCallExpression);\n  }\n\n  if (n.Node.check(node)) {\n    return types.someField(node, function(name, child) {\n      return containsCallExpression(child);\n    });\n  }\n\n  return false;\n}\n\n// Tests if an expression starts with `{`, or (if forbidFunctionAndClass holds) `function` or `class`.\n// Will be overzealous if there's already necessary grouping parentheses.\nfunction startsWithNoLookaheadToken(node, forbidFunctionAndClass) {\n  node = getLeftMost(node);\n  switch (node.type) {\n    case \"FunctionExpression\":\n    case \"ClassExpression\":\n      return forbidFunctionAndClass;\n    case \"ObjectExpression\":\n      return true;\n    case \"MemberExpression\":\n      return startsWithNoLookaheadToken(node.object, forbidFunctionAndClass);\n    case \"TaggedTemplateExpression\":\n      if (node.tag.type === \"FunctionExpression\") {\n        // IIFEs are always already parenthesized\n        return false;\n      }\n      return startsWithNoLookaheadToken(node.tag, forbidFunctionAndClass);\n    case \"CallExpression\":\n      if (node.callee.type === \"FunctionExpression\") {\n        // IIFEs are always already parenthesized\n        return false;\n      }\n      return startsWithNoLookaheadToken(node.callee, forbidFunctionAndClass);\n    case \"ConditionalExpression\":\n      return startsWithNoLookaheadToken(node.test, forbidFunctionAndClass);\n    case \"UpdateExpression\":\n      return (\n        !node.prefix &&\n        startsWithNoLookaheadToken(node.argument, forbidFunctionAndClass)\n      );\n    case \"BindExpression\":\n      return (\n        node.object &&\n        startsWithNoLookaheadToken(node.object, forbidFunctionAndClass)\n      );\n    case \"SequenceExpression\":\n      return startsWithNoLookaheadToken(\n        node.expressions[0],\n        forbidFunctionAndClass\n      );\n    default:\n      return false;\n  }\n}\n\nfunction getLeftMost(node) {\n  if (node.left) {\n    return getLeftMost(node.left);\n  } else {\n    return node;\n  }\n}\n\nmodule.exports = FastPath;\n","/home/travis/build/npmtest/node-npmtest-prettier/node_modules/prettier/src/doc-printer.js":"\"use strict\";\n\nconst MODE_BREAK = 1;\nconst MODE_FLAT = 2;\n\nfunction rootIndent() {\n  return {\n    indent: 0,\n    align: {\n      spaces: 0,\n      tabs: 0\n    }\n  };\n}\n\nfunction makeIndent(ind) {\n  return {\n    indent: ind.indent + 1,\n    align: ind.align\n  };\n}\n\nfunction makeAlign(ind, n) {\n  return {\n    indent: ind.indent,\n    align: {\n      spaces: ind.align.spaces + n,\n      tabs: ind.align.tabs + (n ? 1 : 0)\n    }\n  };\n}\n\nfunction fits(next, restCommands, width) {\n  let restIdx = restCommands.length;\n  const cmds = [next];\n  while (width >= 0) {\n    if (cmds.length === 0) {\n      if (restIdx === 0) {\n        return true;\n      } else {\n        cmds.push(restCommands[restIdx - 1]);\n\n        restIdx--;\n\n        continue;\n      }\n    }\n\n    const x = cmds.pop();\n    const ind = x[0];\n    const mode = x[1];\n    const doc = x[2];\n\n    if (typeof doc === \"string\") {\n      width -= doc.length;\n    } else {\n      switch (doc.type) {\n        case \"concat\":\n          for (var i = doc.parts.length - 1; i >= 0; i--) {\n            cmds.push([ind, mode, doc.parts[i]]);\n          }\n\n          break;\n        case \"indent\":\n          cmds.push([makeIndent(ind), mode, doc.contents]);\n\n          break;\n        case \"align\":\n          cmds.push([makeAlign(ind, doc.n), mode, doc.contents]);\n\n          break;\n        case \"group\":\n          cmds.push([ind, doc.break ? MODE_BREAK : mode, doc.contents]);\n\n          break;\n        case \"if-break\":\n          if (mode === MODE_BREAK) {\n            if (doc.breakContents) {\n              cmds.push([ind, mode, doc.breakContents]);\n            }\n          }\n          if (mode === MODE_FLAT) {\n            if (doc.flatContents) {\n              cmds.push([ind, mode, doc.flatContents]);\n            }\n          }\n\n          break;\n        case \"line\":\n          switch (mode) {\n            // fallthrough\n            case MODE_FLAT:\n              if (!doc.hard) {\n                if (!doc.soft) {\n                  width -= 1;\n                }\n\n                break;\n              }\n\n            case MODE_BREAK:\n              return true;\n          }\n          break;\n      }\n    }\n  }\n  return false;\n}\n\nfunction printDocToString(doc, options) {\n  let width = options.printWidth;\n  let newLine = options.newLine || \"\\n\";\n  let pos = 0;\n  // cmds is basically a stack. We've turned a recursive call into a\n  // while loop which is much faster. The while loop below adds new\n  // cmds to the array instead of recursively calling `print`.\n  let cmds = [[rootIndent(), MODE_BREAK, doc]];\n  let out = [];\n  let shouldRemeasure = false;\n  let lineSuffix = [];\n\n  while (cmds.length !== 0) {\n    const x = cmds.pop();\n    const ind = x[0];\n    const mode = x[1];\n    const doc = x[2];\n\n    if (typeof doc === \"string\") {\n      out.push(doc);\n\n      pos += doc.length;\n    } else {\n      switch (doc.type) {\n        case \"concat\":\n          for (var i = doc.parts.length - 1; i >= 0; i--) {\n            cmds.push([ind, mode, doc.parts[i]]);\n          }\n\n          break;\n        case \"indent\":\n          cmds.push([makeIndent(ind), mode, doc.contents]);\n\n          break;\n        case \"align\":\n          cmds.push([makeAlign(ind, doc.n), mode, doc.contents]);\n\n          break;\n        case \"group\":\n          switch (mode) {\n            // fallthrough\n            case MODE_FLAT:\n              if (!shouldRemeasure) {\n                cmds.push([\n                  ind,\n                  doc.break ? MODE_BREAK : MODE_FLAT,\n                  doc.contents\n                ]);\n\n                break;\n              }\n\n            case MODE_BREAK:\n              shouldRemeasure = false;\n\n              const next = [ind, MODE_FLAT, doc.contents];\n              let rem = width - pos;\n\n              if (!doc.break && fits(next, cmds, rem)) {\n                cmds.push(next);\n              } else {\n                // Expanded states are a rare case where a document\n                // can manually provide multiple representations of\n                // itself. It provides an array of documents\n                // going from the least expanded (most flattened)\n                // representation first to the most expanded. If a\n                // group has these, we need to manually go through\n                // these states and find the first one that fits.\n                if (doc.expandedStates) {\n                  const mostExpanded =\n                    doc.expandedStates[doc.expandedStates.length - 1];\n\n                  if (doc.break) {\n                    cmds.push([ind, MODE_BREAK, mostExpanded]);\n\n                    break;\n                  } else {\n                    for (var i = 1; i < doc.expandedStates.length + 1; i++) {\n                      if (i >= doc.expandedStates.length) {\n                        cmds.push([ind, MODE_BREAK, mostExpanded]);\n\n                        break;\n                      } else {\n                        const state = doc.expandedStates[i];\n                        const cmd = [ind, MODE_FLAT, state];\n\n                        if (fits(cmd, cmds, rem)) {\n                          cmds.push(cmd);\n\n                          break;\n                        }\n                      }\n                    }\n                  }\n                } else {\n                  cmds.push([ind, MODE_BREAK, doc.contents]);\n                }\n              }\n\n              break;\n          }\n          break;\n        case \"if-break\":\n          if (mode === MODE_BREAK) {\n            if (doc.breakContents) {\n              cmds.push([ind, mode, doc.breakContents]);\n            }\n          }\n          if (mode === MODE_FLAT) {\n            if (doc.flatContents) {\n              cmds.push([ind, mode, doc.flatContents]);\n            }\n          }\n\n          break;\n        case \"line-suffix\":\n          lineSuffix.push([ind, mode, doc.contents]);\n          break;\n        case \"line-suffix-boundary\":\n          if (lineSuffix.length > 0) {\n            cmds.push([ind, mode, { type: \"line\", hard: true }]);\n          }\n          break;\n        case \"line\":\n          switch (mode) {\n            // fallthrough\n            case MODE_FLAT:\n              if (!doc.hard) {\n                if (!doc.soft) {\n                  out.push(\" \");\n\n                  pos += 1;\n                }\n\n                break;\n              } else {\n                // This line was forced into the output even if we\n                // were in flattened mode, so we need to tell the next\n                // group that no matter what, it needs to remeasure\n                // because the previous measurement didn't accurately\n                // capture the entire expression (this is necessary\n                // for nested groups)\n                shouldRemeasure = true;\n              }\n\n            case MODE_BREAK:\n              if (lineSuffix.length) {\n                cmds.push([ind, mode, doc]);\n                [].push.apply(cmds, lineSuffix.reverse());\n                lineSuffix = [];\n                break;\n              }\n\n              if (doc.literal) {\n                out.push(newLine);\n                pos = 0;\n              } else {\n                if (out.length > 0) {\n                  // Trim whitespace at the end of line\n                  while (\n                    out.length > 0 &&\n                    out[out.length - 1].match(/^[^\\S\\n]*$/)\n                  ) {\n                    out.pop();\n                  }\n\n                  out[out.length - 1] = out[out.length - 1].replace(\n                    /[^\\S\\n]*$/,\n                    \"\"\n                  );\n                }\n\n                let length = ind.indent * options.tabWidth + ind.align.spaces;\n                let indentString = options.useTabs\n                  ? \"\\t\".repeat(ind.indent + ind.align.tabs)\n                  : \" \".repeat(length);\n                out.push(newLine + indentString);\n                pos = length;\n              }\n              break;\n          }\n          break;\n        default:\n      }\n    }\n  }\n  return out.join(\"\");\n}\n\nmodule.exports = { printDocToString };\n","/home/travis/build/npmtest/node-npmtest-prettier/node_modules/prettier/src/options.js":"\"use strict\";\n\nvar validate = require(\"jest-validate\").validate;\nvar deprecatedConfig = require(\"./deprecated\");\n\nvar defaults = {\n  useTabs: false,\n  tabWidth: 2,\n  printWidth: 80,\n  singleQuote: false,\n  trailingComma: \"none\",\n  bracketSpacing: true,\n  jsxBracketSameLine: false,\n  parser: \"babylon\",\n  semi: true\n};\n\nvar exampleConfig = Object.assign({}, defaults, {\n  filename: \"testFilename\",\n  printWidth: 80,\n  originalText: \"text\"\n});\n\n// Copy options and fill in default values.\nfunction normalize(options) {\n  const normalized = Object.assign({}, options || {});\n\n  if (typeof normalized.trailingComma === \"boolean\") {\n    // Support a deprecated boolean type for the trailing comma config\n    // for a few versions. This code can be removed later.\n    normalized.trailingComma = \"es5\";\n\n    console.warn(\n      \"Warning: `trailingComma` without any argument is deprecated. \" +\n        'Specify \"none\", \"es5\", or \"all\".'\n    );\n  }\n\n  validate(normalized, { exampleConfig, deprecatedConfig });\n\n  // For backward compatibility. Deprecated in 0.0.10\n  if (\"useFlowParser\" in normalized) {\n    normalized.parser = normalized.useFlowParser ? \"flow\" : \"babylon\";\n    delete normalized.useFlowParser;\n  }\n\n  Object.keys(defaults).forEach(k => {\n    if (normalized[k] == null) {\n      normalized[k] = defaults[k];\n    }\n  });\n\n  return normalized;\n}\n\nmodule.exports = { normalize };\n","/home/travis/build/npmtest/node-npmtest-prettier/node_modules/prettier/src/deprecated.js":"\"use strict\";\n\nconst deprecated = {\n  useFlowParser: config =>\n    `  The ${'\"useFlowParser\"'} option is deprecated. Use ${'\"parser\"'} instead.\n\n  Prettier now treats your configuration as:\n  {\n    ${'\"parser\"'}: ${config.useFlowParser ? '\"flow\"' : '\"babylon\"'}\n  }`\n};\n\nmodule.exports = deprecated;\n","/home/travis/build/npmtest/node-npmtest-prettier/node_modules/prettier/src/parser.js":"\"use strict\";\n\nfunction parseWithFlow(text) {\n  // Inline the require to avoid loading all the JS if we don't use it\n  const flowParser = require(\"flow-parser\");\n\n  const ast = flowParser.parse(text, {\n    esproposal_class_instance_fields: true,\n    esproposal_class_static_fields: true,\n    esproposal_export_star_as: true\n  });\n\n  if (ast.errors.length > 0) {\n    // Construct an error similar to the ones thrown by Babylon.\n    const loc = {\n      line: ast.errors[0].loc.start.line,\n      column: ast.errors[0].loc.start.column\n    };\n    const msg =\n      ast.errors[0].message + \" (\" + loc.line + \":\" + loc.column + \")\";\n    const error = new SyntaxError(msg);\n    error.loc = loc;\n    throw error;\n  }\n\n  return ast;\n}\n\nfunction parseWithBabylon(text) {\n  // Inline the require to avoid loading all the JS if we don't use it\n  const babylon = require(\"babylon\");\n\n  return babylon.parse(text, {\n    sourceType: \"module\",\n    allowImportExportEverywhere: false,\n    allowReturnOutsideFunction: false,\n    plugins: [\n      \"jsx\",\n      \"flow\",\n      \"doExpressions\",\n      \"objectRestSpread\",\n      \"decorators\",\n      \"classProperties\",\n      \"exportExtensions\",\n      \"asyncGenerators\",\n      \"functionBind\",\n      \"functionSent\",\n      \"dynamicImport\"\n    ]\n  });\n}\n\nfunction parseWithTypeScript(text) {\n  // While we are working on typescript, we are putting it in devDependencies\n  // so it shouldn't be picked up by static analysis\n  const r = require;\n  const parser = r(\"typescript-eslint-parser\");\n  return parser.parse(text, {\n    loc: true,\n    range: true,\n    tokens: true,\n    attachComment: true,\n    ecmaFeatures: {\n      jsx: true\n    }\n  });\n}\n\nmodule.exports = { parseWithFlow, parseWithBabylon, parseWithTypeScript };\n","/home/travis/build/npmtest/node-npmtest-prettier/node_modules/prettier/src/doc-debug.js":"\"use strict\";\n\nfunction flattenDoc(doc) {\n  if (doc.type === \"concat\") {\n    var res = [];\n\n    for (var i = 0; i < doc.parts.length; ++i) {\n      const doc2 = doc.parts[i];\n      if (typeof doc2 !== \"string\" && doc2.type === \"concat\") {\n        [].push.apply(res, flattenDoc(doc2).parts);\n      } else {\n        const flattened = flattenDoc(doc2);\n        if (flattened !== \"\") {\n          res.push(flattened);\n        }\n      }\n    }\n\n    return Object.assign({}, doc, { parts: res });\n  } else if (doc.type === \"if-break\") {\n    return Object.assign({}, doc, {\n      breakContents: doc.breakContents != null\n        ? flattenDoc(doc.breakContents)\n        : null,\n      flatContents: doc.flatContents != null\n        ? flattenDoc(doc.flatContents)\n        : null\n    });\n  } else if (doc.type === \"group\") {\n    return Object.assign({}, doc, {\n      contents: flattenDoc(doc.contents),\n      expandedStates: doc.expandedStates\n        ? doc.expandedStates.map(flattenDoc)\n        : doc.expandedStates\n    });\n  } else if (doc.contents) {\n    return Object.assign({}, doc, { contents: flattenDoc(doc.contents) });\n  } else {\n    return doc;\n  }\n}\n\nfunction printDoc(doc) {\n  if (typeof doc === \"string\") {\n    return JSON.stringify(doc);\n  }\n\n  if (doc.type === \"line\") {\n    if (doc.literalline) {\n      return \"literalline\";\n    }\n    if (doc.hard) {\n      return \"hardline\";\n    }\n    if (doc.soft) {\n      return \"softline\";\n    }\n    return \"line\";\n  }\n\n  if (doc.type === \"break-parent\") {\n    return \"breakParent\";\n  }\n\n  if (doc.type === \"concat\") {\n    return \"[\" + doc.parts.map(printDoc).join(\", \") + \"]\";\n  }\n\n  if (doc.type === \"indent\") {\n    return \"indent(\" + printDoc(doc.contents) + \")\";\n  }\n\n  if (doc.type === \"align\") {\n    return \"align(\" + doc.n + \", \" + printDoc(doc.contents) + \")\";\n  }\n\n  if (doc.type === \"if-break\") {\n    return (\n      \"ifBreak(\" +\n      printDoc(doc.breakContents) +\n      (doc.flatContents ? \", \" + printDoc(doc.flatContents) : \"\") +\n      \")\"\n    );\n  }\n\n  if (doc.type === \"group\") {\n    if (doc.expandedStates) {\n      return (\n        \"conditionalGroup(\" +\n        \"[\" +\n        doc.expandedStates.map(printDoc).join(\",\") +\n        \"])\"\n      );\n    }\n\n    return (\n      (doc.break ? \"wrappedGroup\" : \"group\") +\n      \"(\" +\n      printDoc(doc.contents) +\n      \")\"\n    );\n  }\n\n  if (doc.type === \"line-suffix\") {\n    return \"lineSuffix(\" + printDoc(doc.contents) + \")\";\n  }\n\n  if (doc.type === \"line-suffix-boundary\") {\n    return \"lineSuffixBoundary\";\n  }\n\n  throw new Error(\"Unknown doc type \" + doc.type);\n}\n\nmodule.exports = {\n  printDocToDebug: function(doc) {\n    return printDoc(flattenDoc(doc));\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-prettier/node_modules/prettier/bin/prettier.js":"#!/usr/bin/env node\n\n\"use strict\";\n\nconst fs = require(\"fs\");\nconst getStdin = require(\"get-stdin\");\nconst glob = require(\"glob\");\nconst chalk = require(\"chalk\");\nconst minimist = require(\"minimist\");\nconst readline = require(\"readline\");\nconst prettier = require(\"../index\");\n\nconst argv = minimist(process.argv.slice(2), {\n  boolean: [\n    \"write\",\n    \"stdin\",\n    \"use-tabs\",\n    \"semi\",\n    \"single-quote\",\n    \"bracket-spacing\",\n    \"jsx-bracket-same-line\",\n    // The supports-color package (a sub sub dependency) looks directly at\n    // `process.argv` for `--no-color` and such-like options. The reason it is\n    // listed here is to avoid \"Ignored unknown option: --no-color\" warnings.\n    // See https://github.com/chalk/supports-color/#info for more information.\n    \"color\",\n    \"list-different\",\n    \"help\",\n    \"version\",\n    \"debug-print-doc\",\n    \"debug-check\",\n    // Deprecated in 0.0.10\n    \"flow-parser\"\n  ],\n  string: [\"print-width\", \"tab-width\", \"parser\", \"trailing-comma\"],\n  default: { semi: true, color: true, \"bracket-spacing\": true, parser: \"babylon\" },\n  alias: { help: \"h\", version: \"v\", \"list-different\": \"l\" },\n  unknown: param => {\n    if (param.startsWith(\"-\")) {\n      console.warn(\"Ignored unknown option: \" + param + \"\\n\");\n      return false;\n    }\n  }\n});\n\nif (argv[\"version\"]) {\n  console.log(prettier.version);\n  process.exit(0);\n}\n\nconst filepatterns = argv[\"_\"];\nconst write = argv[\"write\"];\nconst stdin = argv[\"stdin\"] || (!filepatterns.length && !process.stdin.isTTY);\n\nfunction getParserOption() {\n  const optionName = \"parser\";\n  const value = argv[optionName];\n\n  if (value === undefined) {\n    return value;\n  }\n\n  // For backward compatibility. Deprecated in 0.0.10\n  if (argv[\"flow-parser\"]) {\n    console.warn(\"`--flow-parser` is deprecated. Use `--parser flow` instead.\");\n    return \"flow\";\n  }\n\n  if (value === \"flow\" || value === \"babylon\" || value === \"typescript\") {\n    return value;\n  }\n\n  console.warn(\n    \"Ignoring unknown --\" +\n      optionName +\n      ' value, falling back to \"babylon\":\\n' +\n      '  Expected \"flow\" or \"babylon\", but received: ' +\n      JSON.stringify(value)\n  );\n\n  return \"babylon\";\n}\n\nfunction getIntOption(optionName) {\n  const value = argv[optionName];\n\n  if (value === undefined) {\n    return value;\n  }\n\n  if (/^\\d+$/.test(value)) {\n    return Number(value);\n  }\n\n  console.error(\n    \"Invalid --\" +\n      optionName +\n      \" value. Expected an integer, but received: \" +\n      JSON.stringify(value)\n  );\n  process.exit(1);\n}\n\nfunction getTrailingComma() {\n  switch (argv[\"trailing-comma\"]) {\n    case undefined:\n    case \"none\":\n      return \"none\";\n    case \"\":\n      console.warn(\n        \"Warning: `--trailing-comma` was used without an argument. This is deprecated. \" +\n          'Specify \"none\", \"es5\", or \"all\".'\n      );\n    case \"es5\":\n      return \"es5\";\n    case \"all\":\n      return \"all\";\n    default:\n      throw new Error(\"Invalid option for --trailing-comma\");\n  }\n}\n\nconst options = {\n  useTabs: argv[\"use-tabs\"],\n  semi: argv[\"semi\"],\n  printWidth: getIntOption(\"print-width\"),\n  tabWidth: getIntOption(\"tab-width\"),\n  bracketSpacing: argv[\"bracket-spacing\"],\n  singleQuote: argv[\"single-quote\"],\n  jsxBracketSameLine: argv[\"jsx-bracket-same-line\"],\n  trailingComma: getTrailingComma(),\n  parser: getParserOption()\n};\n\nfunction format(input) {\n  if (argv[\"debug-print-doc\"]) {\n    const doc = prettier.__debug.printToDoc(input, options);\n    return prettier.__debug.formatDoc(doc);\n  }\n\n  if (argv[\"debug-check\"]) {\n    const pp = prettier.format(input, options);\n    const pppp = prettier.format(pp, options);\n    if (pp !== pppp) {\n      const diff = require(\n        \"diff\"\n      ).createTwoFilesPatch(\"\", \"\", pp, pppp, \"\", \"\", { context: 2 });\n      console.error(diff);\n    }\n    return;\n  }\n\n  return prettier.format(input, options);\n}\n\nfunction handleError(filename, e) {\n  const isParseError = Boolean(e && e.loc);\n  const isValidationError = /Validation Error/.test(e && e.message);\n\n  // For parse errors and validation errors, we only want to show the error\n  // message formatted in a nice way. `String(e)` takes care of that. Other\n  // (unexpected) errors are passed as-is as a separate argument to\n  // `console.error`. That includes the stack trace (if any), and shows a nice\n  // `util.inspect` of throws things that aren't `Error` objects. (The Flow\n  // parser has mistakenly thrown arrays sometimes.)\n  if (isParseError) {\n    console.error(filename + \": \" + String(e));\n  } else if (isValidationError) {\n    console.error(String(e));\n    // If validation fails for one file, it will fail for all of them.\n    process.exit(1);\n  } else {\n    console.error(filename + \":\", e);\n  }\n\n  // Don't exit the process if one file failed\n  process.exitCode = 2;\n}\n\nif (argv[\"help\"] || (!filepatterns.length && !stdin)) {\n  console.log(\n    \"Usage: prettier [opts] [filename ...]\\n\\n\" +\n      \"Available options:\\n\" +\n      \"  --write                  Edit the file in-place. (Beware!)\\n\" +\n      \"  --list-different or -l   Print filenames of files that are different from Prettier formatting.\\n\" +\n      \"  --stdin                  Read input from stdin.\\n\" +\n      \"  --print-width <int>      Specify the length of line that the printer will wrap on. Defaults to 80.\\n\" +\n      \"  --tab-width <int>        Specify the number of spaces per indentation-level. Defaults to 2.\\n\" +\n      \"  --use-tabs               Indent lines with tabs instead of spaces.\\n\" +\n      \"  --no-semi                Do not print semicolons, except at the beginning of lines which may need them.\\n\" +\n      \"  --single-quote           Use single quotes instead of double quotes.\\n\" +\n      \"  --no-bracket-spacing     Do not print spaces between brackets.\\n\" +\n      \"  --jsx-bracket-same-line  Put > on the last line instead of at a new line.\\n\" +\n      \"  --trailing-comma <none|es5|all>\\n\" +\n      \"                           Print trailing commas wherever possible. Defaults to none.\\n\" +\n      \"  --parser <flow|babylon>  Specify which parse to use. Defaults to babylon.\\n\" +\n      \"  --no-color               Do not colorize error messages.\\n\" +\n      \"  --version or -v          Print Prettier version.\\n\" +\n      \"\\n\"\n  );\n  process.exit(argv[\"help\"] ? 0 : 1);\n}\n\nif (stdin) {\n  getStdin().then(input => {\n    try {\n      // Don't use `console.log` here since it adds an extra newline at the end.\n      process.stdout.write(format(input));\n    } catch (e) {\n      handleError(\"stdin\", e);\n      return;\n    }\n  });\n} else {\n  eachFilename(filepatterns, filename => {\n    if (write || argv[\"debug-check\"]) {\n      // Don't use `console.log` here since we need to replace this line.\n      process.stdout.write(filename);\n    }\n\n    let input;\n    try {\n      input = fs.readFileSync(filename, \"utf8\");\n    } catch (e) {\n      // Add newline to split errors from filename line.\n      process.stdout.write(\"\\n\");\n\n      console.error(\"Unable to read file: \" + filename + \"\\n\" + e);\n      // Don't exit the process if one file failed\n      process.exitCode = 2;\n      return;\n    }\n\n    if (argv[\"list-different\"]) {\n      if (!prettier.check(input, options)) {\n        console.log(filename);\n        process.exitCode = 1;\n      }\n      return;\n    }\n\n    const start = Date.now();\n\n    let output;\n\n    try {\n      output = format(input);\n    } catch (e) {\n      // Add newline to split errors from filename line.\n      process.stdout.write(\"\\n\");\n\n      handleError(filename, e);\n      return;\n    }\n\n    if (write) {\n      // Remove previously printed filename to log it with duration.\n      readline.clearLine(process.stdout, 0);\n      readline.cursorTo(process.stdout, 0, null);\n\n      // Don't write the file if it won't change in order not to invalidate\n      // mtime based caches.\n      if (output === input) {\n        console.log(chalk.grey(\"%s %dms\"), filename, Date.now() - start);\n      } else {\n        console.log(\"%s %dms\", filename, Date.now() - start);\n\n        try {\n          fs.writeFileSync(filename, output, \"utf8\");\n        } catch (err) {\n          console.error(\"Unable to write file: \" + filename + \"\\n\" + err);\n          // Don't exit the process if one file failed\n          process.exitCode = 2;\n        }\n      }\n    } else if (argv[\"debug-check\"]) {\n      process.stdout.write(\"\\n\");\n      if (output) {\n        console.log(output);\n      }\n    } else {\n      // Don't use `console.log` here since it adds an extra newline at the end.\n      process.stdout.write(output);\n    }\n  });\n}\n\nfunction eachFilename(patterns, callback) {\n  patterns.forEach(pattern => {\n    if (!glob.hasMagic(pattern)) {\n      callback(pattern);\n      return;\n    }\n\n    glob(pattern, (err, filenames) => {\n      if (err) {\n        console.error(\"Unable to expand glob pattern: \" + pattern + \"\\n\" + err);\n        // Don't exit the process if one pattern failed\n        process.exitCode = 2;\n        return;\n      }\n\n      filenames.forEach(filename => {\n        callback(filename);\n      });\n    });\n  });\n}\n"}